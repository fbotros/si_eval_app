<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fadi's 30-Second Typing Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            width: 80%;
            max-width: 800px;
            padding: 2rem;
            border-radius: 10px;
            background-color: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 1.5rem;
        }
        .test-container {
            margin-bottom: 1.5rem;
        }
        .sample-text {
            background-color: #f8f9fa;
            padding: 1rem;
            border-radius: 5px;
            margin-bottom: 1rem;
            font-size: 1.1rem;
            line-height: 1.6;
            border-left: 4px solid #3498db;
        }
        .input-area {
            width: 100%;
            padding: 1rem;
            font-size: 1.1rem;
            border: 2px solid #ddd;
            border-radius: 5px;
            resize: none;
            margin-bottom: 1rem;
            transition: border-color 0.3s;
        }
        .input-area:focus {
            outline: none;
            border-color: #3498db;
        }
        .input-area.disabled {
            background-color: #f5f5f5;
            cursor: not-allowed;
        }
        .timer {
            font-size: 1.5rem;
            text-align: center;
            margin-bottom: 1rem;
            font-weight: bold;
            color: #2c3e50;
        }
        .button {
            display: block;
            width: 200px;
            margin: 0 auto;
            padding: 0.8rem;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .button:hover {
            background-color: #2980b9;
        }
        .button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .results {
            margin-top: 1.5rem;
            padding: 1rem;
            background-color: #f8f9fa;
            border-radius: 5px;
            display: none;
        }
        .results h2 {
            margin-top: 0;
            color: #2c3e50;
        }
        .metric {
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }
        .metric span {
            font-weight: bold;
            color: #3498db;
        }
        .instructions {
            text-align: center;
            margin-bottom: 1rem;
            color: #7f8c8d;
        }
        /* Autocorrect indicator styles */
        .autocorrect-container {
            position: relative;
            margin-bottom: 1rem;
        }
        .input-area {
            margin-bottom: 0 !important;
        }
        .autocorrect-indicator {
            position: absolute;
            top: -40px;
            left: 10px;
            background-color: #3498db; /* Solid color for better visibility */
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 1rem; /* Slightly larger font */
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            display: none; /* Start hidden, use display instead of opacity */
        }
        .autocorrect-indicator::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid #3498db;
        }
        .autocorrect-word {
            font-weight: bold;
            margin-right: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Fadi's 30-Second Typing Test</h1>
        <p class="instructions">Type the text shown below. Press Enter when you finish a prompt to move to the next one. Smart autocorrect is enabled - it will silently fix typos when you press space or punctuation. After the test ends, results will be downloaded as a JSON file.</p>

        <div class="test-container">
            <div class="sample-text" id="sample-text"></div>
            <div class="progress-indicator" style="text-align: center; margin-bottom: 10px; color: #7f8c8d;">
                Prompt <span id="current-prompt">1</span> of <span id="total-prompts">0</span>
            </div>

            <div class="autocorrect-container">
                <textarea class="input-area" id="input-area" placeholder="Start typing here..."></textarea>
                <div class="autocorrect-indicator" id="autocorrect-indicator">
                    <span class="autocorrect-word" id="autocorrect-current-word"></span>
                    <span id="autocorrect-suggestion"></span>
                </div>
            </div>

            <div class="timer" id="timer">Time: 30s</div>

            <button class="button" id="start-button">Reset Test</button>
        </div>

        <div class="results" id="results">
            <h2>Your Average Results</h2>
            <div class="metric">Words per minute: <span id="wpm">0</span></div>
            <div class="metric">Characters per minute: <span id="cpm">0</span></div>
            <div class="metric">Accuracy: <span id="accuracy">0%</span></div>
            <div class="metric">Correct characters: <span id="correct-chars">0</span></div>
            <div class="metric">Incorrect characters: <span id="incorrect-chars">0</span></div>
            <div class="metric">Prompts completed: <span id="prompts-completed">0</span>/<span id="total-prompts-results">0</span></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Array of prompts for the typing test
            const prompts = [
                "The quick brown fox jumps over the lazy dog.",
                "Programming is the process of creating instructions for computers.",
                "JavaScript is a high-level programming language used for web development.",
                "Python is known for its readability and simple syntax.",
                "Artificial intelligence aims to mimic human cognitive functions.",
                "Virtual reality creates an immersive digital environment.",
                "Cloud computing delivers services over the internet.",
                "Cybersecurity protects systems from digital attacks.",
                "Machine learning uses algorithms to analyze and learn from data.",
                "Blockchain is a distributed ledger technology."
            ];

            const sampleTextElement = document.getElementById('sample-text');
            const currentPromptElement = document.getElementById('current-prompt');
            const totalPromptsElement = document.getElementById('total-prompts');

            let currentPromptIndex = 0;
            let promptResults = [];

            // Initialize the first prompt
            totalPromptsElement.textContent = prompts.length;
            updateCurrentPrompt();

            function updateCurrentPrompt() {
                currentPromptElement.textContent = currentPromptIndex + 1;
                sampleTextElement.innerText = prompts[currentPromptIndex];
            }

            // Get the current prompt text
            function getCurrentPromptText() {
                return prompts[currentPromptIndex];
            }
            const inputArea = document.getElementById('input-area');
            const timer = document.getElementById('timer');
            const startButton = document.getElementById('start-button');
            const results = document.getElementById('results');
            const wpmElement = document.getElementById('wpm');
            const cpmElement = document.getElementById('cpm');
            const accuracyElement = document.getElementById('accuracy');
            const correctCharsElement = document.getElementById('correct-chars');
            const incorrectCharsElement = document.getElementById('incorrect-chars');
            const autocorrectIndicator = document.getElementById('autocorrect-indicator');

            let timeLeft = 30;
            let timerInterval;
            let testActive = false;
            let lastTypedWord = '';
            let lastSuggestion = '';
            let startTime = 0; // Track when the current prompt started

            // Function to start the test
            function startTest() {
                if (testActive) return;

                // Start the test
                testActive = true;
                results.style.display = 'none';
                promptResults = []; // Clear previous results
                startTime = Date.now(); // Record start time

                // Start the timer
                timeLeft = 30;
                updateTimerDisplay();
                timerInterval = setInterval(function() {
                    timeLeft--;
                    updateTimerDisplay();

                    if (timeLeft <= 0) {
                        endTest();
                    }
                }, 1000);
            }

            // Dictionary of common words
            const dictionary = [
                // Words from the sample text
                'the', 'quick', 'brown', 'fox', 'jumps', 'over', 'lazy', 'dog',
                'programming', 'is', 'process', 'of', 'creating', 'set', 'instructions',
                'that', 'tell', 'computer', 'how', 'to', 'perform', 'task', 'can', 'be',
                'done', 'using', 'variety', 'languages', 'such', 'as', 'javascript', 'python', 'and',

                // Common English words
                'a', 'an', 'in', 'on', 'at', 'by', 'for', 'with', 'about', 'against',
                'between', 'into', 'through', 'during', 'before', 'after', 'above', 'below',
                'from', 'up', 'down', 'out', 'off', 'over', 'under', 'again', 'further',
                'then', 'once', 'here', 'there', 'when', 'where', 'why', 'how', 'all',
                'any', 'both', 'each', 'few', 'more', 'most', 'some', 'other', 'have',
                'has', 'had', 'do', 'does', 'did', 'but', 'if', 'or', 'because', 'until',
                'while', 'of', 'this', 'these', 'those', 'am', 'are', 'was', 'were',

                // Programming related words
                'function', 'variable', 'code', 'program', 'class', 'object', 'method',
                'array', 'string', 'number', 'boolean', 'null', 'undefined', 'syntax',
                'error', 'debug', 'compile', 'runtime', 'framework', 'library', 'api',
                'interface', 'module', 'component', 'server', 'client', 'database', 'data',
                'file', 'system', 'network', 'web', 'app', 'application', 'development'
            ];

            // Calculate Levenshtein distance between two strings
            function levenshteinDistance(a, b) {
                if (a.length === 0) return b.length;
                if (b.length === 0) return a.length;

                const matrix = [];

                // Initialize matrix
                for (let i = 0; i <= b.length; i++) {
                    matrix[i] = [i];
                }

                for (let j = 0; j <= a.length; j++) {
                    matrix[0][j] = j;
                }

                // Fill in the rest of the matrix
                for (let i = 1; i <= b.length; i++) {
                    for (let j = 1; j <= a.length; j++) {
                        if (b.charAt(i - 1) === a.charAt(j - 1)) {
                            matrix[i][j] = matrix[i - 1][j - 1];
                        } else {
                            matrix[i][j] = Math.min(
                                matrix[i - 1][j - 1] + 1, // substitution
                                matrix[i][j - 1] + 1,     // insertion
                                matrix[i - 1][j] + 1      // deletion
                            );
                        }
                    }
                }

                return matrix[b.length][a.length];
            }

            // Find the closest word in the dictionary
            function findClosestWord(word) {
                // If the word is already in the dictionary, return it
                if (dictionary.includes(word)) {
                    return word;
                }

                let closestWord = null;
                let minDistance = Infinity;

                // Find words with edit distance of up to 2
                for (const dictWord of dictionary) {
                    const distance = levenshteinDistance(word, dictWord);

                    // Consider words with edit distance of 1 or 2
                    if (distance <= 2 && distance < minDistance) {
                        minDistance = distance;
                        closestWord = dictWord;
                    }
                }

                // Return the closest word if found, otherwise return the original word
                return closestWord || word;
            }

            // Function to position the autocorrect indicator
            function positionAutocorrectIndicator() {
                if (!testActive) return;

                const text = inputArea.value;
                const cursorPosition = inputArea.selectionStart;

                // Find the start of the current word
                let wordStart = cursorPosition;
                while (wordStart > 0 && !/[\s.,!?;:"'()]/.test(text.charAt(wordStart - 1))) {
                    wordStart--;
                }

                // Extract the current word
                const currentWord = text.substring(wordStart, cursorPosition).toLowerCase();

                // Skip very short words (1-2 characters)
                if (currentWord.length <= 2) {
                    hideAutocorrectIndicator();
                    lastTypedWord = currentWord;
                    return;
                }

                // Check if the word has changed
                if (currentWord === lastTypedWord) {
                    return;
                }

                lastTypedWord = currentWord;

                // Find the closest word in the dictionary
                const correctedWord = findClosestWord(currentWord);

                // If a correction was found and it's different from the original word
                if (correctedWord !== currentWord) {
                    // Show the autocorrect indicator with the suggested word
                    showAutocorrectIndicator(correctedWord, wordStart);
                    lastSuggestion = correctedWord;
                } else {
                    hideAutocorrectIndicator();
                }
            }

            // Function to show the autocorrect indicator
            function showAutocorrectIndicator(suggestion, wordStart) {
                // Get the current word being typed
                const currentWord = inputArea.value.substring(wordStart, inputArea.selectionStart);

                // Set the indicator text
                document.getElementById('autocorrect-current-word').textContent = currentWord + ' â†’';
                document.getElementById('autocorrect-suggestion').textContent = suggestion;

                // Show the indicator - using display property instead of opacity
                autocorrectIndicator.style.display = 'flex';
            }

            // Function to hide the autocorrect indicator
            function hideAutocorrectIndicator() {
                autocorrectIndicator.style.display = 'none';
            }

            // Start test when user starts typing
            inputArea.addEventListener('input', function(e) {
                if (!testActive) {
                    startTest();
                }

                // No longer check for autocorrections as user types
                // The autocorrect will only happen when space or punctuation is pressed
            });

            // Handle Enter key to move to next prompt
            inputArea.addEventListener('keydown', function(e) {
                if (!testActive) return;

                if (e.key === 'Enter') {
                    e.preventDefault(); // Prevent default Enter behavior

                    // Calculate results for the current prompt
                    const promptResult = calculatePromptResult();
                    promptResults.push(promptResult);

                    // Move to the next prompt or end the test
                    if (currentPromptIndex < prompts.length - 1) {
                        currentPromptIndex++;
                        updateCurrentPrompt();
                        inputArea.value = '';
                        startTime = Date.now(); // Reset start time for the new prompt
                    } else {
                        // End the test if all prompts are completed
                        endTest();
                    }
                }
            });

            // Function to perform autocorrect - improved for cross-browser compatibility
            function performAutocorrect(appendChar) {
                try {
                    const text = inputArea.value;
                    if (text.length > 0) {
                        // Get the last word - more robust splitting
                        const words = text.trim().split(/[\s.,!?;:"'()]/);
                        if (words.length === 0) return false;

                        const lastWord = words[words.length - 1].toLowerCase();

                        // Skip very short words (1-2 characters)
                        if (lastWord.length > 2) {
                            // Find the closest word in the dictionary
                            const correctedWord = findClosestWord(lastWord);

                            // If a correction was found and it's different from the original word
                            if (correctedWord !== lastWord) {
                                // Replace the last word with the corrected one
                                const lastIndex = text.lastIndexOf(lastWord);
                                if (lastIndex !== -1) {
                                    const newText = text.substring(0, lastIndex) + correctedWord;

                                    // Direct update approach for better cross-browser compatibility
                                    inputArea.value = newText + appendChar;

                                    // Try to move cursor to the end - wrapped in try/catch for browser compatibility
                                    try {
                                        inputArea.selectionStart = inputArea.value.length;
                                        inputArea.selectionEnd = inputArea.value.length;
                                    } catch (e) {
                                        // Some browsers might not support selection manipulation
                                        console.log("Selection adjustment not supported");
                                    }

                                    // Hide the indicator after correction
                                    hideAutocorrectIndicator();

                                    return true; // Correction was made
                                }
                            }
                        }
                    }
                    return false; // No correction was made
                } catch (error) {
                    console.error("Autocorrect error:", error);
                    return false; // Error occurred, don't attempt correction
                }
            }

            // Add autocorrect functionality with improved browser compatibility
            inputArea.addEventListener('keydown', function(e) {
                if (!testActive) return;

                // Check for space or punctuation
                const punctuation = [' ', '.', ',', '!', '?', ';', ':', '"', "'", '(', ')'];
                const key = e.key || String.fromCharCode(e.keyCode || e.which);

                if (punctuation.includes(key)) {
                    // Perform autocorrect and append the pressed character
                    try {
                        if (performAutocorrect(key)) {
                            e.preventDefault(); // Prevent default if correction was made
                        }
                    } catch (error) {
                        console.error("Error in autocorrect keydown handler:", error);
                    }
                }
            });

            // Reset button functionality
            startButton.addEventListener('click', function() {
                resetTest();
            });

            function updateTimerDisplay() {
                timer.textContent = `Time: ${timeLeft}s`;
            }

            function endTest() {
                clearInterval(timerInterval);
                testActive = false;

                // Disable the input area so users can't type anymore
                inputArea.disabled = true;

                // Change button text
                startButton.textContent = 'Start New Test';

                // Hide the autocorrect indicator
                hideAutocorrectIndicator();

                // Calculate results for the current prompt if not already done
                if (inputArea.value.trim().length > 0) {
                    const promptResult = calculatePromptResult();
                    promptResults.push(promptResult);
                }

                // Calculate and display average results
                calculateAverageResults();

                // Display results
                results.style.display = 'block';
            }

            function resetTest() {
                clearInterval(timerInterval);
                testActive = false;
                timeLeft = 30;
                updateTimerDisplay();
                inputArea.value = '';
                inputArea.disabled = false;
                startButton.textContent = 'Reset Test';
                results.style.display = 'none';
                hideAutocorrectIndicator();

                // Reset prompt index and update display
                currentPromptIndex = 0;
                updateCurrentPrompt();
                promptResults = [];
            }

            // Calculate results for the current prompt
            function calculatePromptResult() {
                const typedText = inputArea.value;
                const promptText = getCurrentPromptText();
                const typedLength = typedText.length;
                const promptLength = promptText.length;

                // Use Levenshtein distance to calculate edit distance
                const editDistance = levenshteinDistance(typedText, promptText);

                // Calculate accuracy as 1 minus normalized edit distance
                const maxDistance = Math.max(typedLength, promptLength);
                const normalizedDistance = maxDistance > 0 ? editDistance / maxDistance : 0;
                const accuracy = Math.floor((1 - normalizedDistance) * 100);

                // Calculate correct and incorrect characters
                let correctChars = 0;
                let incorrectChars = 0;

                for (let i = 0; i < typedLength; i++) {
                    if (i < promptLength && typedText[i] === promptText[i]) {
                        correctChars++;
                    } else {
                        incorrectChars++;
                    }
                }

                // Calculate time spent on this prompt in minutes
                const endTime = Date.now();
                const timeSpentMs = endTime - startTime;
                const minutes = timeSpentMs / 60000; // Convert ms to minutes

                // Calculate WPM and CPM
                const words = typedLength / 5; // Assume average word is 5 characters
                const wpm = minutes > 0 ? Math.floor(words / minutes) : 0;
                const cpm = minutes > 0 ? Math.floor(typedLength / minutes) : 0;

                return {
                    promptIndex: currentPromptIndex,
                    promptText: promptText,
                    typedText: typedText,
                    wpm: wpm,
                    cpm: cpm,
                    accuracy: accuracy,
                    editDistance: editDistance,
                    correctChars: correctChars,
                    incorrectChars: incorrectChars,
                    totalChars: typedLength,
                    timeSpentMs: timeSpentMs
                };
            }

            // Calculate average results across all completed prompts
            function calculateAverageResults() {
                if (promptResults.length === 0) {
                    return;
                }

                // Calculate averages
                let totalWpm = 0;
                let totalCpm = 0;
                let totalAccuracy = 0;
                let totalCorrectChars = 0;
                let totalIncorrectChars = 0;
                let totalChars = 0;

                promptResults.forEach(result => {
                    totalWpm += result.wpm;
                    totalCpm += result.cpm;
                    totalAccuracy += result.accuracy;
                    totalCorrectChars += result.correctChars;
                    totalIncorrectChars += result.incorrectChars;
                    totalChars += result.totalChars;
                });

                const avgWpm = Math.floor(totalWpm / promptResults.length);
                const avgCpm = Math.floor(totalCpm / promptResults.length);
                const avgAccuracy = Math.floor(totalAccuracy / promptResults.length);

                // Update results display
                wpmElement.textContent = avgWpm;
                cpmElement.textContent = avgCpm;
                accuracyElement.textContent = `${avgAccuracy}%`;
                correctCharsElement.textContent = totalCorrectChars;
                incorrectCharsElement.textContent = totalIncorrectChars;
                document.getElementById('prompts-completed').textContent = promptResults.length;
                document.getElementById('total-prompts-results').textContent = prompts.length;

                // Create results object with both individual prompt results and averages
                const resultsData = {
                    date: new Date().toISOString(),
                    averageWpm: avgWpm,
                    averageCpm: avgCpm,
                    averageAccuracy: avgAccuracy,
                    totalCorrectChars: totalCorrectChars,
                    totalIncorrectChars: totalIncorrectChars,
                    totalChars: totalChars,
                    promptsCompleted: promptResults.length,
                    totalPrompts: prompts.length,
                    promptResults: promptResults
                };

                // Download results as JSON
                downloadResultsAsJson(resultsData);
            }

            function downloadResultsAsJson(data) {
                // Create a JSON string from the data
                const jsonString = JSON.stringify(data, null, 2);

                // Create a Blob with the JSON data
                const blob = new Blob([jsonString], { type: 'application/json' });

                // Create a URL for the Blob
                const url = URL.createObjectURL(blob);

                // Create a temporary link element
                const link = document.createElement('a');
                link.href = url;

                // Set the filename with date
                const date = new Date();
                const formattedDate = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;
                link.download = `typing-test-results-${formattedDate}.json`;

                // Append the link to the body
                document.body.appendChild(link);

                // Trigger the download
                link.click();

                // Clean up
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }
        });
    </script>
</body>
</html>
