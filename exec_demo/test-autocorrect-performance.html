<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autocorrect Performance Tests</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background-color: #f5f5f5;
        }

        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .test-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .test-result {
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            font-family: monospace;
        }

        .test-pass {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .test-fail {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .performance-result {
            background-color: #cce7ff;
            color: #004085;
            border: 1px solid #99d6ff;
            font-weight: bold;
        }

        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }

        button:hover {
            background: #0056b3;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }

        .stat-label {
            font-size: 14px;
            color: #6c757d;
        }

        .progress {
            width: 100%;
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-bar {
            height: 100%;
            background-color: #007bff;
            transition: width 0.3s ease;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>üöÄ Autocorrect Performance & Unit Tests</h1>
        <p>Testing the optimized TrieDictionary-based autocorrect system vs brute force approach</p>
    </div>

    <div class="test-section">
        <h2>üîß System Initialization</h2>
        <button onclick="initializeSystem()">Initialize Test System</button>
        <div id="init-results"></div>

        <div class="stats" id="system-stats" style="display: none;">
            <div class="stat-card">
                <div class="stat-value" id="dict-size">-</div>
                <div class="stat-label">Dictionary Words</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="trie-available">-</div>
                <div class="stat-label">TrieDictionary Available</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="keyboard-neighbors">-</div>
                <div class="stat-label">Keyboard Neighbors</div>
            </div>
        </div>
    </div>

    <div class="test-section">
        <h2>üß™ Unit Tests</h2>
        <button onclick="runUnitTests()">Run All Unit Tests</button>
        <div id="unit-test-results"></div>
    </div>

    <div class="test-section">
        <h2>‚ö° Performance Tests</h2>
        <button onclick="runPerformanceTests()">Run Performance Comparison</button>
        <div class="progress" id="perf-progress" style="display: none;">
            <div class="progress-bar" id="perf-progress-bar"></div>
        </div>
        <div id="performance-results"></div>
    </div>

    <div class="test-section">
        <h2>üéØ Real-World Typing Simulation</h2>
        <button onclick="runTypingSimulation()">Simulate Real Typing Scenario</button>
        <div id="typing-results"></div>
    </div>

    <!-- Load dependencies -->
    <script src="dictionary-loader.js"></script>
    <script src="keyboard-layout.js"></script>
    <script src="TrieDictionary.js"></script>
    <script src="AutocorrectEngine.js"></script>

    <script>
        let testAutocorrectEngine = null;
        let legacyAutocorrectEngine = null;

        // Test data
        const testWords = [
            // Common typos
            { input: 'helo', expected: 'hello' },
            { input: 'wrold', expected: 'world' },
            { input: 'teh', expected: 'the' },
            { input: 'adn', expected: 'and' },
            { input: 'wiht', expected: 'with' },
            
            // Keyboard adjacent errors
            { input: 'gello', expected: 'hello' }, // g->h (adjacent keys)
            { input: 'workd', expected: 'world' }, // k->l (adjacent keys)  
            { input: 'yhe', expected: 'the' },     // y->t (adjacent keys)
            
            // Longer words
            { input: 'improtant', expected: 'important' },
            { input: 'seperate', expected: 'separate' },
            { input: 'recieve', expected: 'receive' },
            
            // Words that should not be corrected
            { input: 'hello', expected: 'hello' },
            { input: 'world', expected: 'world' },
            { input: 'the', expected: 'the' },
            
            // Edge cases
            { input: 'a', expected: 'a' },       // Very short word
            { input: 'jumpe', expected: 'jumped' }, // Should find "jumped" in our enhanced dictionary
            { input: 'walkin', expected: 'walking' }, // Should find "walking"
            
            // Two-word splits
            { input: 'helloworld', expected: 'hello world' },
            { input: 'thequick', expected: 'the quick' },
        ];

        async function initializeSystem() {
            const resultsDiv = document.getElementById('init-results');
            const statsDiv = document.getElementById('system-stats');
            
            resultsDiv.innerHTML = '<div class="test-result">Loading dictionary and initializing engines...</div>';

            try {
                // Load dictionary
                const dictionary = await loadDictionary();
                
                // Create optimized engine (with TrieDictionary)
                testAutocorrectEngine = new AutocorrectEngine({
                    baseWords: dictionary,
                    keyboardNeighbors: typeof keyboardNeighbors !== 'undefined' ? keyboardNeighbors : {},
                    maxEditDistance: 2,
                    adjacentKeyMultiplier: 0.4
                });

                // Create legacy engine (force disable TrieDictionary for comparison)
                legacyAutocorrectEngine = new AutocorrectEngine({
                    baseWords: dictionary,
                    keyboardNeighbors: typeof keyboardNeighbors !== 'undefined' ? keyboardNeighbors : {},
                    maxEditDistance: 2,
                    adjacentKeyMultiplier: 0.4
                });
                // Force disable trie for legacy comparison
                legacyAutocorrectEngine.trieDictionary = null;

                const stats = testAutocorrectEngine.getStats();
                
                resultsDiv.innerHTML = '<div class="test-result test-pass">‚úÖ System initialized successfully!</div>';
                
                // Update stats
                document.getElementById('dict-size').textContent = stats.dictionarySize.toLocaleString();
                document.getElementById('trie-available').textContent = stats.hasTrieDictionary ? '‚úÖ' : '‚ùå';
                document.getElementById('keyboard-neighbors').textContent = stats.keyboardNeighborsCount;
                
                statsDiv.style.display = 'grid';
                
            } catch (error) {
                resultsDiv.innerHTML = `<div class="test-result test-fail">‚ùå Initialization failed: ${error.message}</div>`;
            }
        }

        function runUnitTests() {
            const resultsDiv = document.getElementById('unit-test-results');
            
            if (!testAutocorrectEngine) {
                resultsDiv.innerHTML = '<div class="test-result test-fail">‚ùå Please initialize system first</div>';
                return;
            }

            let results = '';
            let passCount = 0;
            let totalTests = 0;

            // Test basic correction functionality
            results += '<h3>üî§ Basic Correction Tests</h3>';
            
            testWords.forEach((test, index) => {
                totalTests++;
                const correction = testAutocorrectEngine.findClosestWord(test.input);
                const passed = correction === test.expected;
                
                if (passed) passCount++;
                
                const className = passed ? 'test-pass' : 'test-fail';
                const icon = passed ? '‚úÖ' : '‚ùå';
                
                results += `<div class="test-result ${className}">${icon} Test ${index + 1}: "${test.input}" ‚Üí "${correction}" (expected: "${test.expected}")</div>`;
            });

            // Test TrieDictionary integration
            results += '<h3>üå≥ TrieDictionary Integration Tests</h3>';
            
            // Test that TrieDictionary is being used
            totalTests++;
            const hasTrieDict = testAutocorrectEngine.getStats().hasTrieDictionary;
            if (hasTrieDict) {
                passCount++;
                results += '<div class="test-result test-pass">‚úÖ TrieDictionary is available and initialized</div>';
            } else {
                results += '<div class="test-result test-fail">‚ùå TrieDictionary is not available</div>';
            }

            // Test candidate generation efficiency
            totalTests++;
            if (testAutocorrectEngine.trieDictionary) {
                const candidates = testAutocorrectEngine.trieDictionary.search('hello', 2);
                const candidateCount = candidates.length;
                
                if (candidateCount > 0 && candidateCount < 500) { // Should be much less than full dictionary
                    passCount++;
                    results += `<div class="test-result test-pass">‚úÖ TrieDictionary generates reasonable candidate count: ${candidateCount} candidates for "hello"</div>`;
                } else {
                    results += `<div class="test-result test-fail">‚ùå TrieDictionary candidate count seems wrong: ${candidateCount} candidates</div>`;
                }
            } else {
                results += '<div class="test-result test-fail">‚ùå TrieDictionary instance not available for testing</div>';
            }

            // Test caching
            results += '<h3>üíæ Caching Tests</h3>';
            totalTests++;
            
            // Clear cache and test
            testAutocorrectEngine.clearCache();
            const firstCall = performance.now();
            testAutocorrectEngine.findClosestWord('helo');
            const firstCallTime = performance.now() - firstCall;
            
            const secondCall = performance.now();
            testAutocorrectEngine.findClosestWord('helo');
            const secondCallTime = performance.now() - secondCall;
            
            if (secondCallTime < firstCallTime * 0.8) { // Cache should make it faster
                passCount++;
                results += `<div class="test-result test-pass">‚úÖ Caching works: First call ${firstCallTime.toFixed(2)}ms, Second call ${secondCallTime.toFixed(2)}ms</div>`;
            } else {
                results += `<div class="test-result test-fail">‚ùå Caching may not be working: First call ${firstCallTime.toFixed(2)}ms, Second call ${secondCallTime.toFixed(2)}ms</div>`;
            }

            // Test keyboard-aware corrections
            results += '<h3>‚å®Ô∏è Keyboard-Aware Correction Tests</h3>';
            totalTests++;
            
            const keyboardTest = testAutocorrectEngine.findClosestWord('gello'); // g->h are adjacent
            if (keyboardTest === 'hello') {
                passCount++;
                results += '<div class="test-result test-pass">‚úÖ Keyboard-aware correction works: "gello" ‚Üí "hello"</div>';
            } else {
                results += `<div class="test-result test-fail">‚ùå Keyboard-aware correction failed: "gello" ‚Üí "${keyboardTest}" (expected "hello")</div>`;
            }

            // Summary
            results += `<h3>üìä Test Summary</h3>`;
            const successRate = ((passCount / totalTests) * 100).toFixed(1);
            const summaryClass = passCount === totalTests ? 'test-pass' : (passCount > totalTests * 0.8 ? 'performance-result' : 'test-fail');
            results += `<div class="test-result ${summaryClass}">Passed ${passCount}/${totalTests} tests (${successRate}%)</div>`;

            resultsDiv.innerHTML = results;
        }

        async function runPerformanceTests() {
            const resultsDiv = document.getElementById('performance-results');
            const progressDiv = document.getElementById('perf-progress');
            const progressBar = document.getElementById('perf-progress-bar');
            
            if (!testAutocorrectEngine || !legacyAutocorrectEngine) {
                resultsDiv.innerHTML = '<div class="test-result test-fail">‚ùå Please initialize system first</div>';
                return;
            }

            progressDiv.style.display = 'block';
            resultsDiv.innerHTML = '';

            const testCases = [
                'helo', 'wrold', 'teh', 'improtant', 'seperate', 'recieve',
                'gello', 'workd', 'yhe', 'jumpe', 'walkin', 'typng', 'performanc',
                'algoritm', 'efficent', 'optimizd', 'respons', 'accurac'
            ];

            let results = '<h3>‚ö° Performance Comparison: Optimized vs Legacy</h3>';

            // Warm up both engines
            testCases.forEach(word => {
                testAutocorrectEngine.findClosestWord(word);
                legacyAutocorrectEngine.findClosestWord(word);
            });

            // Clear caches for fair comparison
            testAutocorrectEngine.clearCache();
            legacyAutocorrectEngine.clearCache();

            let totalOptimizedTime = 0;
            let totalLegacyTime = 0;
            let testCount = 0;

            for (let i = 0; i < testCases.length; i++) {
                const word = testCases[i];
                testCount++;
                
                // Update progress
                const progress = ((i + 1) / testCases.length) * 100;
                progressBar.style.width = progress + '%';

                // Test optimized (TrieDictionary) approach
                const optimizedStart = performance.now();
                const optimizedResult = testAutocorrectEngine.findClosestWord(word);
                const optimizedTime = performance.now() - optimizedStart;
                totalOptimizedTime += optimizedTime;

                // Test legacy (brute force) approach  
                const legacyStart = performance.now();
                const legacyResult = legacyAutocorrectEngine.findClosestWord(word);
                const legacyTime = performance.now() - legacyStart;
                totalLegacyTime += legacyTime;

                // Verify both approaches give same result
                const sameResult = optimizedResult === legacyResult;
                const resultIcon = sameResult ? '‚úÖ' : '‚ö†Ô∏è';
                
                results += `<div class="test-result ${sameResult ? 'test-pass' : 'performance-result'}">
                    ${resultIcon} "${word}": Optimized ${optimizedTime.toFixed(2)}ms vs Legacy ${legacyTime.toFixed(2)}ms 
                    (${(legacyTime / optimizedTime).toFixed(1)}x faster) ‚Üí "${optimizedResult}"
                </div>`;

                // Small delay to not block UI
                if (i % 5 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }

            const avgOptimizedTime = totalOptimizedTime / testCount;
            const avgLegacyTime = totalLegacyTime / testCount;
            const speedup = avgLegacyTime / avgOptimizedTime;

            results += `<h3>üìà Performance Summary</h3>`;
            results += `<div class="test-result performance-result">
                <strong>Average Performance:</strong><br>
                ‚Ä¢ Optimized (TrieDictionary): ${avgOptimizedTime.toFixed(2)}ms per correction<br>
                ‚Ä¢ Legacy (Brute Force): ${avgLegacyTime.toFixed(2)}ms per correction<br>
                ‚Ä¢ <strong>Speed Improvement: ${speedup.toFixed(1)}x faster!</strong><br>
                ‚Ä¢ Total time saved: ${(totalLegacyTime - totalOptimizedTime).toFixed(2)}ms over ${testCount} corrections
            </div>`;

            const expectedSpeedup = 50; // We expect around 50-200x improvement
            if (speedup >= expectedSpeedup) {
                results += `<div class="test-result test-pass">üéâ Excellent! Performance improvement exceeds expectations (${speedup.toFixed(1)}x >= ${expectedSpeedup}x)</div>`;
            } else if (speedup >= 10) {
                results += `<div class="test-result performance-result">üëç Good performance improvement (${speedup.toFixed(1)}x), but could be better</div>`;
            } else {
                results += `<div class="test-result test-fail">‚ö†Ô∏è Performance improvement is lower than expected (${speedup.toFixed(1)}x < 10x)</div>`;
            }

            progressDiv.style.display = 'none';
            resultsDiv.innerHTML = results;
        }

        async function runTypingSimulation() {
            const resultsDiv = document.getElementById('typing-results');
            
            if (!testAutocorrectEngine) {
                resultsDiv.innerHTML = '<div class="test-result test-fail">‚ùå Please initialize system first</div>';
                return;
            }

            let results = '<h3>‚å®Ô∏è Real-World Typing Simulation</h3>';
            
            // Simulate a user typing a sentence with typos
            const typingScenario = [
                { typed: 'h', expected: null },
                { typed: 'he', expected: null },
                { typed: 'hel', expected: null },
                { typed: 'helo', expected: 'hello' },
                { typed: 'helo ', corrected: 'hello ' },
                
                { typed: 'hello w', expected: null },
                { typed: 'hello wo', expected: null },
                { typed: 'hello wor', expected: null },
                { typed: 'hello worl', expected: null },
                { typed: 'hello wrold', expected: 'world' },
                { typed: 'hello wrold ', corrected: 'hello world ' },
                
                { typed: 'hello world t', expected: null },
                { typed: 'hello world th', expected: null },
                { typed: 'hello world teh', expected: 'the' },
                { typed: 'hello world teh ', corrected: 'hello world the ' },
                
                { typed: 'hello world the q', expected: null },
                { typed: 'hello world the qu', expected: null },
                { typed: 'hello world the qui', expected: null },
                { typed: 'hello world the quic', expected: null },
                { typed: 'hello world the quick', expected: 'quick' },
            ];

            let totalPreviewTime = 0;
            let totalCorrectionTime = 0;
            let previewCount = 0;
            let correctionCount = 0;

            for (const scenario of typingScenario) {
                if (scenario.expected !== undefined) {
                    // This is a preview scenario (user is still typing)
                    const start = performance.now();
                    const words = scenario.typed.trim().split(' ');
                    const lastWord = words[words.length - 1];
                    const suggestion = testAutocorrectEngine.findClosestWordForPreview(lastWord);
                    const time = performance.now() - start;
                    
                    totalPreviewTime += time;
                    previewCount++;
                    
                    const expectedSuggestion = scenario.expected || lastWord;
                    const correct = suggestion === expectedSuggestion;
                    const icon = correct ? '‚úÖ' : '‚ùå';
                    
                    results += `<div class="test-result ${correct ? 'test-pass' : 'test-fail'}">
                        ${icon} Preview: "${lastWord}" ‚Üí "${suggestion}" in ${time.toFixed(2)}ms
                    </div>`;
                    
                } else if (scenario.corrected !== undefined) {
                    // This is a correction scenario (user hit space)
                    const start = performance.now();
                    const words = scenario.typed.trim().split(' ');
                    const lastWord = words[words.length - 1];
                    const correction = testAutocorrectEngine.findClosestWord(lastWord);
                    const time = performance.now() - start;
                    
                    totalCorrectionTime += time;
                    correctionCount++;
                    
                    results += `<div class="test-result performance-result">
                        üîÑ Correction: "${lastWord}" ‚Üí "${correction}" in ${time.toFixed(2)}ms
                    </div>`;
                }
                
                // Small delay to simulate real typing
                await new Promise(resolve => setTimeout(resolve, 1));
            }

            const avgPreviewTime = previewCount > 0 ? totalPreviewTime / previewCount : 0;
            const avgCorrectionTime = correctionCount > 0 ? totalCorrectionTime / correctionCount : 0;

            results += `<h3>üìä Typing Performance Summary</h3>`;
            results += `<div class="test-result performance-result">
                <strong>Real-time Performance:</strong><br>
                ‚Ä¢ Average preview time: ${avgPreviewTime.toFixed(2)}ms (should be < 16ms for 60fps)<br>
                ‚Ä¢ Average correction time: ${avgCorrectionTime.toFixed(2)}ms<br>
                ‚Ä¢ Total previews: ${previewCount}<br>
                ‚Ä¢ Total corrections: ${correctionCount}
            </div>`;

            // Evaluate if performance is suitable for real-time typing
            if (avgPreviewTime < 16) {
                results += `<div class="test-result test-pass">üéØ Excellent! Preview performance supports 60fps real-time typing</div>`;
            } else if (avgPreviewTime < 33) {
                results += `<div class="test-result performance-result">üëç Good! Preview performance supports 30fps typing</div>`;
            } else {
                results += `<div class="test-result test-fail">‚ö†Ô∏è Preview performance may cause typing lag (${avgPreviewTime.toFixed(2)}ms > 33ms)</div>`;
            }

            resultsDiv.innerHTML = results;
        }

        // Auto-initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Small delay to ensure all scripts are loaded
            setTimeout(initializeSystem, 100);
        });
    </script>
</body>

</html>