<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doc Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f9f9f9;
            min-height: 100vh;
        }

        .page-header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            padding: 28px 40px;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .page-title {
            text-align: left;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .page-title svg {
            width: 24px;
            height: 24px;
            flex-shrink: 0;
        }

        .document-title-container {
            position: relative;
            display: inline-flex;
            align-items: center;
        }

        .document-title-input {
            border: 1px solid transparent;
            background: transparent;
            padding: 6px 10px;
            font-size: 24px;
            font-weight: 400;
            color: #2d3748;
            margin: -7px -11px;
            outline: none;
            transition: all 0.2s ease;
            width: auto;
            min-width: 200px;
            border-radius: 6px;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .document-title-input:hover {
            border-color: rgba(0, 0, 0, 0.15);
            background: rgba(255, 255, 255, 0.5);
        }

        .document-title-input:focus {
            border-color: rgba(102, 126, 234, 0.4);
            background: rgba(255, 255, 255, 0.8);
        }

        .document-title-input:focus+.edit-icon {
            opacity: 0;
        }

        .edit-icon {
            width: 16px;
            height: 16px;
            opacity: 0.4;
            pointer-events: none;
            flex-shrink: 0;
            margin-left: 6px;
            transition: opacity 0.2s ease;
        }

        .main-content {
            display: flex;
            justify-content: center;
            padding: 40px 20px;
        }

        .container {
            width: 100%;
            max-width: 850px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 0;
            overflow: hidden;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .toolbar-header {
            background: #f5f5f5;
            padding: 2px 0;
            border-bottom: 1px solid #e3e3e3;
            position: sticky;
            top: 80px;
            z-index: 99;
        }

        .toolbar {
            max-width: 850px;
            margin: 0 auto;
            padding: 0 106px 0 0;
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .toolbar button {
            background: transparent;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: #4a5568;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 36px;
            height: 36px;
        }

        .toolbar button:hover {
            background: #e0e0e0;
        }

        .toolbar button.active {
            background: #d0d0d0;
            color: #2d3748;
        }

        .toolbar select {
            background: transparent;
            border: none;
            border-radius: 6px;
            padding: 8px 8px 8px 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: #4a5568;
            transition: background-color 0.2s ease;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            width: auto;
            padding-right: 24px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12"><path fill="%234a5568" d="M6 9L1 4h10z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 6px center;
        }

        .toolbar select:hover {
            background-color: #e0e0e0;
        }

        .toolbar select option {
            background: white;
            color: #2d3748;
        }

        .toolbar .separator {
            width: 1px;
            height: 24px;
            background: rgba(0, 0, 0, 0.1);
            margin: 0 8px;
        }

        #document-editor {
            min-height: 1000px;
            padding: 106px 106px 106px 106px;
            outline: none;
            font-size: 36pt;
            line-height: 1.7;
            color: #2d3748;
            background: transparent;
            border: none;
            font-family: Arial, sans-serif;
        }

        #document-editor:focus {
            outline: none;
        }


        /* Format styles for content */
        .bold {
            font-weight: bold;
        }

        .italic {
            font-style: italic;
        }

        .underline {
            text-decoration: underline;
        }

        .strikethrough {
            text-decoration: line-through;
        }

        /* Focus styles removed - keep consistent drop shadow */

        /* Autocorrect Tooltip - EXACT COPY from typing test modal */
        .autocorrect-tooltip {
            position: absolute;
            background: white;
            color: #333;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #3498db;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transform: translateY(-2px);
            transition: opacity 0.15s ease, transform 0.15s ease;
            white-space: nowrap;
            /* Match document editor font */
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 18px;
            font-weight: normal;
            line-height: 1.2;
        }

        .autocorrect-tooltip.show {
            opacity: 1;
            transform: translateY(0);
        }

        .autocorrect-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            right: 8px;
            border: 5px solid transparent;
            border-top-color: #3498db;
        }

        .autocorrect-tooltip::before {
            content: '';
            position: absolute;
            top: 100%;
            right: 8px;
            border: 6px solid transparent;
            border-top-color: white;
            margin-top: -1px;
        }
    </style>
</head>

<body>
    <div class="page-header">
        <h1 class="page-title">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M14 2H6C5.46957 2 4.96086 2.21071 4.58579 2.58579C4.21071 2.96086 4 3.46957 4 4V20C4 20.5304 4.21071 21.0391 4.58579 21.4142C4.96086 21.7893 5.46957 22 6 22H18C18.5304 22 19.0391 21.7893 19.4142 21.4142C19.7893 21.0391 20 20.5304 20 20V8L14 2Z"
                    stroke="#2d3748" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                <path d="M14 2V8H20" stroke="#2d3748" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                <path d="M16 13H8" stroke="#2d3748" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                <path d="M16 17H8" stroke="#2d3748" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                <path d="M10 9H9H8" stroke="#2d3748" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
            </svg>
            <div class="document-title-container">
                <input type="text" class="document-title-input" value="Surface Inputs PRD" id="document-title">
                <svg class="edit-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path
                        d="M17.2929 2.29291C17.6834 1.90238 18.3166 1.90238 18.7071 2.29291L21.7071 5.29291C22.0976 5.68343 22.0976 6.31659 21.7071 6.70712L8.70711 19.7071C8.51957 19.8947 8.26522 20 8 20H5C4.44772 20 4 19.5523 4 19V16C4 15.7348 4.10536 15.4804 4.29289 15.2929L17.2929 2.29291Z"
                        stroke="#9CA3AF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                    <path d="M15 5L19 9" stroke="#9CA3AF" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" />
                </svg>
            </div>
        </h1>
        <div
            style="position: absolute; top: 10px; right: 20px; font-size: 10px; color: #999; font-family: monospace; user-select: none;">
            v0.1
        </div>
    </div>

    <!-- Toolbar Header -->
    <div class="toolbar-header">
        <div class="toolbar">
            <button id="bold-btn" title="Bold (Ctrl+B)">B</button>
            <button id="italic-btn" title="Italic (Ctrl+I)"><em>I</em></button>
            <button id="underline-btn" title="Underline (Ctrl+U)"><u>U</u></button>
            <select id="font-size-selector" title="Font Size">
                <option value="9">9</option>
                <option value="11">11</option>
                <option value="13" selected>13</option>
                <option value="16">16</option>
                <option value="18">18</option>
                <option value="24">24</option>
                <option value="36">36</option>
            </select>
        </div>
    </div>

    <div class="main-content">
        <div class="container">

            <!-- Document Editor -->
            <div id="document-editor" contenteditable="true" spellcheck="false" autocorrect="off" autocapitalize="off"
                autocomplete="off" data-gramm="false" data-gramm_editor="false" data-enable-grammarly="false"
                translate="no" data-ms-editor="false" data-lt-tmp-id="lt-0" data-lt-installed="false"
                data-grammarly-disable="true"><div><font size="7">Surface Inputs PRD</font></div><div><font size="3"><b>Status</b>: (WIP | RFC | <b>RFC</b>)</font></div><div><font size="3"><b>Editors/Contributors</b>: Ohad Yahalom, Mark Richardson, Fadi Botros, Patrick Grady</font></div><div><font size="3"><b>Last Update</b>: Feb 14, 2025</font></div><div><br></div><div><font size="6">Framing</font></div><div><font size="3">Surface inputs (SI) combines a virtual keyboard and trackpad to support general purpose computing in AR and VR. This document outlines our high level plan for releasing SI and the key requirements for an MVP experience that is good enough to meet the expectations of early adopter users in mixed reality environments.</font></div><div><br></div><div><font size="6">Product Intercept</font></div><div><font size="3">Surface Inputs will launch on Quest 3 as experimental features in V85 (January 2026). We will learn and iterate for day-0 launches on both Phoenix (VR) and Artemis (AR).</font></div></div>
        </div>
    </div>

    <!-- Autocorrect tooltip - positioned outside of contentEditable -->
    <div id="autocorrect-tooltip" class="autocorrect-tooltip"></div>


    <!-- Load external scripts -->
    <script src="../dictionary-loader.js"></script>
    <script src="../AutocorrectEngine.js"></script>
    <script>

        // Wait for DOM to be ready
        document.addEventListener('DOMContentLoaded', function () {
            initializeEditor();
        });

        function initializeEditor() {
            // Get DOM elements
            const editor = document.getElementById('document-editor');
            const titleInput = document.getElementById('document-title');

            if (!editor || !titleInput) {
                console.error('Required DOM elements not found');
                return;
            }

            // Formatting buttons
            const fontSizeSelector = document.getElementById('font-size-selector');
            const boldBtn = document.getElementById('bold-btn');
            const italicBtn = document.getElementById('italic-btn');
            const underlineBtn = document.getElementById('underline-btn');

            // Initialize autocorrect engine
            let editorAutocorrectEngine = null;
            let autocorrectReady = false;

            // Global variable to store current autocorrect suggestion
            let currentAutocorrectSuggestion = null;
            let wordToReplaceWithSuggestion = null; // Store the word when we show suggestion

            // Initialize dictionary and autocorrect engine
            async function initializeAutocorrect() {
                try {
                    const dictionary = await loadDictionary('../comprehensive_dictionary.txt');

                    // Define QWERTY keyboard neighbor mappings
                    const keyboardNeighbors = {
                        'q': ['w', 'a'],
                        'w': ['q', 'e', 's', 'a'],
                        'e': ['w', 'r', 'd', 's'],
                        'r': ['e', 't', 'f', 'd'],
                        't': ['r', 'y', 'g', 'f'],
                        'y': ['t', 'u', 'h', 'g'],
                        'u': ['y', 'i', 'j', 'h'],
                        'i': ['u', 'o', 'k', 'j'],
                        'o': ['i', 'p', 'l', 'k'],
                        'p': ['o', 'l'],
                        'a': ['q', 'w', 's', 'z'],
                        's': ['a', 'w', 'e', 'd', 'z', 'x'],
                        'd': ['s', 'e', 'r', 'f', 'x', 'c'],
                        'f': ['d', 'r', 't', 'g', 'c', 'v'],
                        'g': ['f', 't', 'y', 'h', 'v', 'b'],
                        'h': ['g', 'y', 'u', 'j', 'b', 'n'],
                        'j': ['h', 'u', 'i', 'k', 'n', 'm'],
                        'k': ['j', 'i', 'o', 'l', 'm'],
                        'l': ['k', 'o', 'p'],
                        'z': ['a', 's', 'x'],
                        'x': ['z', 's', 'd', 'c'],
                        'c': ['x', 'd', 'f', 'v'],
                        'v': ['c', 'f', 'g', 'b'],
                        'b': ['v', 'g', 'h', 'n'],
                        'n': ['b', 'h', 'j', 'm'],
                        'm': ['n', 'j', 'k']
                    };

                    // Create autocorrect engine with dictionary words and keyboard neighbors
                    editorAutocorrectEngine = new AutocorrectEngine({
                        keyboardNeighbors: keyboardNeighbors,
                        adjacentKeyMultiplier: 0.5,  // Make adjacent key substitutions very cheap
                        substitutionCost: 1.0,
                        insertionCost: 0.5,
                        deletionCost: 1.0,
                        apostropheInsertionCost: 0.3,  // Increased from 0.2 to make it less attractive
                        apostropheDeletionCost: 0.4    // Increased from 0.3 to make it less attractive
                    });
                    editorAutocorrectEngine.addWords(dictionary);
                    autocorrectReady = true;
                } catch (error) {
                    console.error('âŒ Failed to initialize autocorrect:', error);
                }
            }

            // Start initialization
            initializeAutocorrect();

            // Format functions
            function toggleFormat(command) {
                try {
                    document.execCommand(command, false, null);

                    updateToolbarState();
                    editor.focus();
                } catch (error) {
                }
            }

            function changeFont(fontName) {
                try {

                    // Set manually controlled font family - updateToolbarState will use this
                    manuallySetFontFamily = fontName;

                    // Quest 3 fix: Restore saved selection before execCommand
                    const wasRestored = restoreSavedSelection();

                    const selection = window.getSelection();
                    const hadSelection = selection.rangeCount > 0 && !selection.getRangeAt(0).collapsed;

                    // execCommand will maintain selection automatically
                    document.execCommand('fontName', false, fontName);

                    // Update dropdown to show what we just applied
                    fontSelector.value = fontName;
                    resizeFontSelector();
                    editor.focus();


                    // Clear the manual override after a short delay
                    setTimeout(() => {
                        manuallySetFontFamily = null;
                    }, 100);
                } catch (error) {
                }
            }

            function changeFontSize(fontSize) {
                try {

                    // Set manually controlled font size - updateToolbarState will use this
                    manuallySetFontSize = fontSize;

                    // Quest 3 fix: Restore saved selection before execCommand
                    const wasRestored = restoreSavedSelection();

                    // Save selection state for debugging and restoration
                    const selection = window.getSelection();
                    const hadSelection = selection.rangeCount > 0 && !selection.getRangeAt(0).collapsed;

                    // Try using execCommand with fontSize (uses HTML size 1-7)
                    // Map our pt sizes to HTML sizes roughly
                    const htmlSizeMap = {
                        '9': '1',
                        '11': '2',
                        '13': '3',
                        '16': '4',
                        '18': '5',
                        '24': '6',
                        '36': '7'
                    };

                    const htmlSize = htmlSizeMap[fontSize] || '3';

                    // execCommand will maintain the selection for us
                    document.execCommand('fontSize', false, htmlSize);


                    // Update dropdown immediately
                    fontSizeSelector.value = fontSize;
                    resizeFontSizeSelector();
                    editor.focus();


                    // Clear the manual override after a short delay
                    // This allows next toolbar update to work normally
                    setTimeout(() => {
                        manuallySetFontSize = null;
                    }, 100);

                } catch (error) {
                }
            }

            // Helper function to get first text node in an element
            function getFirstTextNode(element) {
                if (element.nodeType === Node.TEXT_NODE) {
                    return element;
                }
                for (let child of element.childNodes) {
                    const textNode = getFirstTextNode(child);
                    if (textNode) return textNode;
                }
                return null;
            }

            // Helper function to get last text node in an element
            function getLastTextNode(element) {
                if (element.nodeType === Node.TEXT_NODE) {
                    return element;
                }
                const children = Array.from(element.childNodes);
                for (let i = children.length - 1; i >= 0; i--) {
                    const textNode = getLastTextNode(children[i]);
                    if (textNode) return textNode;
                }
                return null;
            }


            // Auto-resize font size selector to fit current selection
            function resizeFontSizeSelector() {
                const selector = document.getElementById('font-size-selector');
                if (!selector) return;

                // Create a temporary span to measure text width
                const tempSpan = document.createElement('span');
                tempSpan.style.position = 'absolute';
                tempSpan.style.visibility = 'hidden';
                tempSpan.style.height = 'auto';
                tempSpan.style.width = 'auto';
                tempSpan.style.whiteSpace = 'nowrap';
                tempSpan.style.fontSize = '14px';
                tempSpan.style.fontWeight = '600';
                tempSpan.style.fontFamily = getComputedStyle(selector).fontFamily;
                tempSpan.textContent = selector.options[selector.selectedIndex].text;

                document.body.appendChild(tempSpan);
                const textWidth = tempSpan.offsetWidth;
                document.body.removeChild(tempSpan);

                // Set selector width to text width plus left padding (12px) + right padding for arrow (24px) + buffer (4px)
                selector.style.width = (textWidth + 40) + 'px';
            }

            // Track if we should skip next toolbar update (to avoid overwriting user's manual change)
            let skipNextToolbarUpdate = false;

            // Track manually set formatting that should override DOM reads
            let manuallySetFontSize = null;
            let manuallySetFontFamily = null;

            function updateToolbarState() {
                if (skipNextToolbarUpdate) {
                    skipNextToolbarUpdate = false;
                    return;
                }

                boldBtn.classList.toggle('active', document.queryCommandState('bold'));
                italicBtn.classList.toggle('active', document.queryCommandState('italic'));
                underlineBtn.classList.toggle('active', document.queryCommandState('underline'));

                // Get the element at cursor position
                const elementAtCursor = getElementAtCursor();

                // Update font size selector - ONLY READ, don't apply
                if (elementAtCursor) {
                    try {
                        let fontSizeToUse = null;

                        // Use manually set font size if available
                        if (manuallySetFontSize) {
                            fontSizeToUse = manuallySetFontSize;
                        } else {
                            // Read from DOM
                            const computedStyle = window.getComputedStyle(elementAtCursor);
                            const fontSize = computedStyle.fontSize;

                            if (fontSize) {
                                // Convert px to pt (1pt = 1.333px approximately)
                                const fontSizePt = Math.round(parseFloat(fontSize) * 0.75);
                                fontSizeToUse = fontSizePt.toString();
                            }
                        }

                        if (fontSizeToUse) {
                            // Try to match with one of our options
                            const sizeOptions = Array.from(fontSizeSelector.options);
                            const matchingSize = sizeOptions.find(opt =>
                                opt.value === fontSizeToUse
                            );
                            if (matchingSize) {
                                fontSizeSelector.value = matchingSize.value;
                                resizeFontSizeSelector();
                                // DO NOT call execCommand here - it causes recursive calls during input events
                            }
                        }
                    } catch (e) {
                        // If fails, keep current selection
                    }
                }
            }

            // Helper function to get the element at cursor position
            function getElementAtCursor() {
                try {
                    const selection = window.getSelection();
                    if (selection.rangeCount === 0) return null;

                    const range = selection.getRangeAt(0);
                    let container = range.startContainer;


                    // FIRST: Check if container is an element node (not editor)
                    // This catches cases where cursor is inside an empty formatted element
                    if (container.nodeType === Node.ELEMENT_NODE && container !== editor) {
                        // Check if this element is empty - if so, look at previous sibling
                        const isEmpty = container.textContent.trim() === '';

                        if (isEmpty && container.previousSibling) {
                            let prevSibling = container.previousSibling;
                            // Skip text nodes that are just whitespace
                            while (prevSibling && prevSibling.nodeType === Node.TEXT_NODE && prevSibling.textContent.trim() === '') {
                                prevSibling = prevSibling.previousSibling;
                            }
                            if (prevSibling) {
                                if (prevSibling.nodeType === Node.ELEMENT_NODE) {
                                    return prevSibling;
                                } else if (prevSibling.nodeType === Node.TEXT_NODE && prevSibling.parentElement) {
                                    return prevSibling.parentElement;
                                }
                            }
                        }

                        return container;
                    }

                    // SECOND: If it's a text node, return its parent (simple and correct)
                    if (container.nodeType === Node.TEXT_NODE) {
                        const parent = container.parentElement;
                        return parent;
                    }

                    // If container is the editor itself, try to find the actual element at cursor
                    if (container === editor) {
                        // Check if there's content before the cursor
                        if (range.startOffset > 0) {
                            const nodeBefore = editor.childNodes[range.startOffset - 1];
                            if (nodeBefore) {
                                if (nodeBefore.nodeType === Node.TEXT_NODE) {
                                    return nodeBefore.parentElement;
                                } else if (nodeBefore.nodeType === Node.ELEMENT_NODE &&
                                    !nodeBefore.classList?.contains('autocorrect-tooltip')) {
                                    return nodeBefore;
                                }
                            }
                        }

                        // Check if there's content at or after the cursor
                        if (range.startOffset < editor.childNodes.length) {
                            const nodeAt = editor.childNodes[range.startOffset];
                            if (nodeAt) {
                                if (nodeAt.nodeType === Node.TEXT_NODE) {
                                    return nodeAt.parentElement;
                                } else if (nodeAt.nodeType === Node.ELEMENT_NODE &&
                                    !nodeAt.classList?.contains('autocorrect-tooltip')) {
                                    return nodeAt;
                                }
                            }
                        }

                        // Fallback: use the editor itself
                        return editor;
                    }

                    return container;
                } catch (e) {
                    return null;
                }
            }


            // Event listeners
            fontSizeSelector.addEventListener('change', (e) => {
                const beforeValue = e.target.value;
                const beforeIndex = e.target.selectedIndex;

                changeFontSize(e.target.value);


                resizeFontSizeSelector();

            });

            // Additional debugging: log clicks on dropdown
            fontSizeSelector.addEventListener('mousedown', () => {
            });
            fontSizeSelector.addEventListener('focus', () => {
            });
            boldBtn.addEventListener('click', () => toggleFormat('bold'));
            italicBtn.addEventListener('click', () => toggleFormat('italic'));
            underlineBtn.addEventListener('click', () => toggleFormat('underline'));

            // Keyboard shortcuts
            editor.addEventListener('keydown', function (e) {
                if (e.ctrlKey || e.metaKey) {
                    switch (e.key) {
                        case 'b':
                            e.preventDefault();
                            toggleFormat('bold');
                            break;
                        case 'i':
                            e.preventDefault();
                            toggleFormat('italic');
                            break;
                        case 'u':
                            e.preventDefault();
                            toggleFormat('underline');
                            break;
                        case 'z':
                            if (e.shiftKey) {
                                e.preventDefault();
                                document.execCommand('redo');
                            } else {
                                e.preventDefault();
                                document.execCommand('undo');
                            }
                            updateToolbarState();
                            break;
                        case 'y':
                            e.preventDefault();
                            document.execCommand('redo');
                            updateToolbarState();
                            break;
                    }
                }
            });

            // Update toolbar state on input
            editor.addEventListener('input', function () {
                updateToolbarState();
            });

            // Update toolbar state on selection change
            document.addEventListener('selectionchange', function () {
                if (document.activeElement === editor) {
                    updateToolbarState();
                }
            });

            // Focus editor on load
            editor.addEventListener('focus', function () {
                // Clear placeholder text on first focus
                if (editor.innerText === 'Start typing your document here...') {
                    editor.innerHTML = '';
                }
            });

            // Auto-resize title input to fit content
            function resizeTitleInput() {
                const input = document.getElementById('document-title');
                if (!input) return;

                // Create a temporary span to measure text width
                const tempSpan = document.createElement('span');
                tempSpan.style.position = 'absolute';
                tempSpan.style.visibility = 'hidden';
                tempSpan.style.height = 'auto';
                tempSpan.style.width = 'auto';
                tempSpan.style.whiteSpace = 'nowrap';
                tempSpan.style.fontSize = '24px';
                tempSpan.style.fontWeight = '400';
                tempSpan.style.fontFamily = getComputedStyle(input).fontFamily;
                tempSpan.textContent = input.value || input.placeholder || 'Untitled Document';

                document.body.appendChild(tempSpan);
                const textWidth = tempSpan.offsetWidth;
                document.body.removeChild(tempSpan);

                // Set input width to text width plus padding (20px) plus a bit of buffer (10px)
                input.style.width = (textWidth + 30) + 'px';
            }

            // Update input width on change
            titleInput.addEventListener('input', resizeTitleInput);
            titleInput.addEventListener('change', resizeTitleInput);

            // Select all text when clicking on the title input
            titleInput.addEventListener('click', function () {
                this.select();
            });

            // Also select all on focus (for keyboard navigation)
            titleInput.addEventListener('focus', function () {
                this.select();
            });

            // Tooltip management functions
            function showAutocorrectTooltip(text, x, y) {
                const tooltip = document.getElementById('autocorrect-tooltip');
                if (!tooltip) return;

                tooltip.textContent = text;
                tooltip.classList.remove('show');

                // Get the editor's position on the page
                const editorRect = editor.getBoundingClientRect();
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

                // Convert relative coordinates to absolute page coordinates
                const absoluteX = editorRect.left + scrollLeft + x;
                const absoluteY = editorRect.top + scrollTop + y;

                tooltip.style.position = 'absolute';
                tooltip.style.visibility = 'visible';
                tooltip.style.top = '0px';
                tooltip.style.left = '0px';

                // Force layout to get measurements
                const tooltipWidth = tooltip.offsetWidth;
                const tooltipHeight = tooltip.offsetHeight;

                // Position tooltip - align arrow (8px from right) with cursor, shifted 10px right
                let finalX = absoluteX - tooltipWidth + 8 + 10 - 3;
                let finalY = absoluteY;

                // Ensure tooltip doesn't go off screen edges
                const viewportWidth = window.innerWidth;
                if (finalX + tooltipWidth > viewportWidth - 10) {
                    finalX = viewportWidth - tooltipWidth - 10;
                }
                if (finalX < 10) {
                    finalX = 10;
                }
                if (finalY < 0) {
                    finalY = absoluteY + 30; // Position below cursor
                }

                tooltip.style.left = finalX + 'px';
                tooltip.style.top = finalY + 'px';
                tooltip.classList.add('show');
            }

            function hideAutocorrectTooltip() {
                const tooltip = document.getElementById('autocorrect-tooltip');
                if (tooltip) {
                    tooltip.classList.remove('show');
                    tooltip.style.visibility = 'hidden';
                }
            }

            // Get current word being typed
            function getCurrentWord() {
                if (!editorAutocorrectEngine) return '';

                const selection = window.getSelection();
                if (selection.rangeCount === 0) return '';

                try {
                    const range = selection.getRangeAt(0);

                    // Get FULL editor text using innerText (preserves newlines)
                    const fullEditorText = getEditorText();

                    // Calculate cursor position by matching what innerText does
                    let cursorPos = 0;
                    let foundCursor = false;

                    // Helper to recursively walk nodes and calculate position
                    function walkNodes(node, isFirstChild) {
                        if (foundCursor) return;

                        // If this is a text node
                        if (node.nodeType === Node.TEXT_NODE) {
                            if (node === range.startContainer) {
                                // Found the cursor - add only up to the offset
                                cursorPos += range.startOffset;
                                foundCursor = true;
                                return;
                            } else {
                                // Add full text length
                                cursorPos += node.textContent.length;
                            }
                        } else if (node.nodeType === Node.ELEMENT_NODE) {
                            // Check if this element creates a line break
                            if (node.nodeName === 'BR') {
                                cursorPos += 1; // BR = newline
                            } else if (node.nodeName === 'DIV' && node !== editor) {
                                // DIVs in contentEditable create line breaks
                                // But ONLY add newline if this isn't the first div AND it has content
                                if (!isFirstChild && cursorPos > 0) {
                                    cursorPos += 1;
                                }
                            }

                            // Walk through children
                            const children = Array.from(node.childNodes);
                            for (let i = 0; i < children.length; i++) {
                                walkNodes(children[i], i === 0 && isFirstChild);
                                if (foundCursor) break;
                            }
                        }
                    }

                    walkNodes(editor, true);

                    // Get text before cursor from full text
                    const textBeforeCursor = fullEditorText.substring(0, cursorPos);

                    // Extract word at end - stops at ANY whitespace including \n
                    const wordMatch = textBeforeCursor.match(/[\w']+$/);
                    const currentWord = wordMatch ? wordMatch[0] : '';

                    return currentWord;

                } catch (error) {
                    console.error('Error in getCurrentWord:', error);
                    return '';
                }
            }

            // Replace current word with autocorrect suggestion
            function replaceCurrentWord(wordToDelete, suggestion) {
                try {
                    const selection = window.getSelection();
                    if (selection.rangeCount === 0) return;

                    const range = selection.getRangeAt(0);

                    // Create a new range to select exactly the word we want to replace
                    const wordRange = document.createRange();

                    // Move the range start backwards by the word length
                    let startContainer = range.startContainer;
                    let startOffset = range.startOffset;

                    // Move backwards character by character to find the word start
                    let remainingChars = wordToDelete.length;

                    while (remainingChars > 0 && startContainer) {
                        if (startContainer.nodeType === Node.TEXT_NODE) {
                            const availableChars = startOffset;
                            const charsToTake = Math.min(remainingChars, availableChars);

                            startOffset -= charsToTake;
                            remainingChars -= charsToTake;

                            if (remainingChars > 0) {
                                // Need to go to previous text node
                                const walker = document.createTreeWalker(
                                    editor,
                                    NodeFilter.SHOW_TEXT,
                                    null,
                                    false
                                );
                                walker.currentNode = startContainer;
                                const prevNode = walker.previousNode();
                                if (prevNode) {
                                    startContainer = prevNode;
                                    startOffset = prevNode.textContent.length;
                                } else {
                                    break;
                                }
                            }
                        } else {
                            break;
                        }
                    }

                    // Set the range to select exactly the word
                    wordRange.setStart(startContainer, startOffset);
                    wordRange.setEnd(range.startContainer, range.startOffset);

                    // Verify we're selecting the right text
                    const selectedText = wordRange.toString();

                    if (selectedText === wordToDelete) {
                        // Select and replace the word
                        selection.removeAllRanges();
                        selection.addRange(wordRange);
                        document.execCommand('insertText', false, suggestion);
                    } else {
                        // Fallback to original method
                        for (let i = 0; i < wordToDelete.length; i++) {
                            document.execCommand('delete', false, null);
                        }
                        document.execCommand('insertText', false, suggestion);
                    }

                } catch (error) {
                    console.error('Error replacing word:', error);
                    // Fallback to simple deletion method
                    try {
                        for (let i = 0; i < wordToDelete.length; i++) {
                            document.execCommand('delete', false, null);
                        }
                        document.execCommand('insertText', false, suggestion);
                    } catch (fallbackError) {
                        console.error('Fallback replacement also failed:', fallbackError);
                    }
                }
            }

            // Get cursor position for tooltip placement
            function getCursorPosition() {
                const selection = window.getSelection();
                if (selection.rangeCount === 0) return null;

                try {
                    const range = selection.getRangeAt(0);
                    const rect = range.getBoundingClientRect();

                    // Get editor bounds to calculate relative position
                    const editorRect = editor.getBoundingClientRect();

                    // Calculate position relative to the editor container
                    return {
                        x: rect.left - editorRect.left, // Relative to editor
                        y: rect.top - editorRect.top - 35 // Relative to editor, positioned above text
                    };
                } catch (error) {
                    return null;
                }
            }

            // Check if current word started at a word boundary (after whitespace)
            function isAtWordBoundary() {
                try {
                    const selection = window.getSelection();
                    if (selection.rangeCount === 0) return true;

                    const range = selection.getRangeAt(0);
                    let fullText = editor.innerText || '';
                    fullText = fullText.replace(/\n+$/, '');

                    // Calculate cursor position using the SAME logic as getCurrentWord
                    let cursorPos = 0;
                    if (range.startContainer === editor) {
                        const childNodes = Array.from(editor.childNodes);
                        for (let i = 0; i < Math.min(range.startOffset, childNodes.length); i++) {
                            const node = childNodes[i];
                            if (node.nodeType === Node.TEXT_NODE) {
                                cursorPos += node.textContent.length;
                            } else if (node.nodeType === Node.ELEMENT_NODE) {
                                cursorPos += node.innerText ? node.innerText.length : 0;
                            }
                        }
                    } else {
                        const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null, false);
                        let currentOffset = 0;
                        while (walker.nextNode()) {
                            const node = walker.currentNode;
                            if (node === range.startContainer) {
                                cursorPos = currentOffset + range.startOffset;
                                break;
                            }
                            currentOffset += node.textContent.length;
                        }
                    }

                    // Apply same cursor position fixes as getCurrentWord
                    if (cursorPos > fullText.length) {
                        cursorPos = fullText.length;
                    }

                    if (range.startContainer.nodeType === Node.TEXT_NODE &&
                        range.startOffset === range.startContainer.textContent.length) {
                        const nodeText = range.startContainer.textContent;
                        const expectedPos = fullText.lastIndexOf(nodeText);
                        if (expectedPos !== -1 && expectedPos + nodeText.length !== cursorPos) {
                            cursorPos = expectedPos + nodeText.length;
                        }
                    }

                    // Check if cursor is right after whitespace
                    if (cursorPos === 0) return true; // At start of document

                    const prevChar = fullText[cursorPos - 1];
                    return /\s/.test(prevChar); // True if cursor is right after whitespace
                } catch (error) {
                    return true; // Default to allow if error
                }
            }

            // Helper to get text - use innerText which preserves newlines from contentEditable
            function getEditorText() {
                // innerText respects the visual layout and newlines
                let text = editor.innerText || '';

                // Strip only trailing newlines (contentEditable adds these at end)
                text = text.replace(/\n+$/, '');

                return text;
            }

            // Track autocorrect state - intelligent suppression approach
            let autocorrectEnabled = true;
            let justAppliedAutocorrect = false;
            let lastTextLength = 0;
            let lastCursorPosition = 0;
            let lastTextContent = ''; // Track the actual text content

            // Track pending font size for Quest 3 compatibility
            let pendingFontSize = '11'; // Default

            // Helper to check if the character before cursor is a delimiter (whitespace/punctuation)
            function isDelimiterBeforeCursor() {
                try {
                    const fullText = getEditorText();
                    const cursorPos = getCursorOffset();

                    // At start of document = delimiter boundary
                    if (cursorPos === 0) return true;

                    // Check character before cursor
                    const charBeforeCursor = fullText[cursorPos - 1];

                    // Whitespace or punctuation = delimiter
                    return /[\s,;.!?'"\/\-]/.test(charBeforeCursor);
                } catch (error) {
                    return true; // Default to safe state
                }
            }

            // Check for autocorrect suggestions
            function checkForAutocorrect() {
                if (!editorAutocorrectEngine || !autocorrectReady) {
                    return;
                }

                const currentWord = getCurrentWord();

                // If autocorrect is disabled, check if we should re-enable it
                if (!autocorrectEnabled) {
                    if (currentWord.length === 0 || isDelimiterBeforeCursor()) {
                        autocorrectEnabled = true;
                    } else {
                        currentAutocorrectSuggestion = null;
                        hideAutocorrectTooltip();
                        return;
                    }
                }

                if (currentWord.length < 3) {
                    currentAutocorrectSuggestion = null;
                    hideAutocorrectTooltip();
                    return;
                }

                // Check if possessive form is valid (base word exists in dictionary)
                if (currentWord.endsWith("'s")) {
                    const baseWord = currentWord.slice(0, -2); // Remove 's
                    if (editorAutocorrectEngine.dictionarySet && editorAutocorrectEngine.dictionarySet.has(baseWord.toLowerCase())) {
                        currentAutocorrectSuggestion = null;
                        hideAutocorrectTooltip();
                        return;
                    }
                }

                // Check if word is capitalized (for preserving capitalization in suggestions)
                const isCapitalized = currentWord[0] === currentWord[0].toUpperCase() && currentWord.length > 1;

                // Create lowercase version for dictionary lookup
                const wordForLookup = isCapitalized ? currentWord.toLowerCase() : currentWord;

                // Use findClosestWord for ALL corrections - it handles:
                // 1. Override corrections (highest priority)
                // 2. Dictionary lookups
                // 3. Single-word corrections with cost calculation
                // 4. Two-word splits with cost calculation
                // 5. Comparison between single-word and two-word to pick the best
                const suggestion = editorAutocorrectEngine.findClosestWord(wordForLookup);

                // Show tooltip if suggestion is different from original input
                if (suggestion && suggestion !== wordForLookup && suggestion !== currentWord.toLowerCase()) {
                    // Capitalize suggestion if original word was capitalized
                    let finalSuggestion = suggestion;
                    if (isCapitalized && suggestion.length > 0) {
                        finalSuggestion = suggestion.charAt(0).toUpperCase() + suggestion.slice(1);
                    }

                    currentAutocorrectSuggestion = finalSuggestion;
                    wordToReplaceWithSuggestion = currentWord;

                    const cursorPos = getCursorPosition();
                    if (cursorPos) {
                        showAutocorrectTooltip(finalSuggestion, cursorPos.x, cursorPos.y);
                    }
                } else {
                    currentAutocorrectSuggestion = null;
                    wordToReplaceWithSuggestion = null;
                    hideAutocorrectTooltip();
                }
            }

            // Debounced autocorrect check
            let autocorrectTimeout;
            function debouncedAutocorrectCheck() {
                clearTimeout(autocorrectTimeout);
                autocorrectTimeout = setTimeout(checkForAutocorrect, 200);
            }

            // Track last typed key to detect space/punctuation
            let lastTypedKey = '';

            // Add keydown listener to track what key was pressed
            editor.addEventListener('keydown', function (e) {
                lastTypedKey = e.key;
            });

            // Helper to get cursor offset in text - uses SAME node-walking logic as getCurrentWord
            function getCursorOffset() {
                const selection = window.getSelection();
                if (!selection.rangeCount) return 0;

                const range = selection.getRangeAt(0);

                // Calculate cursor position by walking through the editor's text nodes
                // This is the SAME logic used in getCurrentWord()
                let cursorPos = 0;
                let foundCursor = false;

                function walkNodes(node) {
                    if (foundCursor) return;

                    // If this is a text node
                    if (node.nodeType === Node.TEXT_NODE) {
                        if (node === range.startContainer) {
                            // Found the cursor - add only up to the offset
                            cursorPos += range.startOffset;
                            foundCursor = true;
                            return;
                        } else {
                            // Add full text length
                            cursorPos += node.textContent.length;
                        }
                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                        // Check if this element is a BR or creates a line break
                        if (node.nodeName === 'BR') {
                            cursorPos += 1; // BR = newline
                        } else if (node.nodeName === 'DIV' && node !== editor) {
                            // DIVs in contentEditable create line breaks (except the root editor)
                            const childNodes = Array.from(node.childNodes);
                            if (childNodes.length > 0) {
                                // Add newline before the div's content (if not first div)
                                if (cursorPos > 0) {
                                    cursorPos += 1;
                                }
                            }
                        }

                        // Walk through children
                        for (const child of node.childNodes) {
                            walkNodes(child);
                            if (foundCursor) break;
                        }
                    }
                }

                walkNodes(editor);
                return cursorPos;
            }


            // Helper to get consistent text length (matching what getCurrentWord uses)
            function getConsistentTextLength() {
                return getEditorText().length;
            }


            // Add input listener for autocorrect tooltips (suggestion-only)
            editor.addEventListener('input', function (e) {
                // Clean up empty formatted elements after deletion
                if (e.inputType === 'deleteContentBackward' || e.inputType === 'deleteContentForward') {
                    const selection = window.getSelection();
                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        let container = range.startContainer;
                        let parent = null;

                        // If cursor is in a text node, check its parent
                        if (container.nodeType === Node.TEXT_NODE) {
                            parent = container.parentElement;
                        } else {
                            parent = container;
                        }

                        // Check if we're in an empty formatted element (FONT, SPAN, etc.)
                        if (parent && parent !== editor && parent.nodeType === Node.ELEMENT_NODE) {
                            const isEmpty = parent.textContent.trim() === '';

                            if (isEmpty && (parent.tagName === 'FONT' || parent.tagName === 'SPAN')) {
                                // This element is now empty - remove it and move cursor to previous sibling
                                const prevSibling = parent.previousSibling;

                                // Remove the empty element
                                parent.remove();

                                // Move cursor to end of previous sibling if it exists
                                if (prevSibling) {
                                    const newRange = document.createRange();
                                    if (prevSibling.nodeType === Node.TEXT_NODE) {
                                        newRange.setStart(prevSibling, prevSibling.length);
                                        newRange.setEnd(prevSibling, prevSibling.length);
                                    } else if (prevSibling.nodeType === Node.ELEMENT_NODE) {
                                        // Find the last text node in the element
                                        const lastTextNode = getLastTextNode(prevSibling);
                                        if (lastTextNode) {
                                            newRange.setStart(lastTextNode, lastTextNode.length);
                                            newRange.setEnd(lastTextNode, lastTextNode.length);
                                        } else {
                                            // No text node, just position at end of element
                                            newRange.selectNodeContents(prevSibling);
                                            newRange.collapse(false);
                                        }
                                    }
                                    selection.removeAllRanges();
                                    selection.addRange(newRange);
                                }
                            }
                        }

                        // Also check if cursor is at END of a text node and there's an empty element AFTER it
                        if (container.nodeType === Node.TEXT_NODE && range.startOffset === container.length) {
                            // Look for empty FONT/SPAN elements after this text node
                            let nextNode = container.nextSibling;
                            while (nextNode) {
                                if (nextNode.nodeType === Node.ELEMENT_NODE &&
                                    (nextNode.tagName === 'FONT' || nextNode.tagName === 'SPAN')) {
                                    const isEmpty = nextNode.textContent.trim() === '';
                                    if (isEmpty) {
                                        const toRemove = nextNode;
                                        nextNode = nextNode.nextSibling; // Move to next before removing
                                        toRemove.remove();
                                    } else {
                                        break; // Found non-empty element, stop
                                    }
                                } else if (nextNode.nodeType === Node.TEXT_NODE && nextNode.textContent.trim() === '') {
                                    // Skip whitespace text nodes
                                    nextNode = nextNode.nextSibling;
                                } else {
                                    break; // Found non-empty content, stop
                                }
                            }
                        }
                    }
                }

                const currentTextContent = getEditorText();
                const currentTextLength = currentTextContent.length;
                const currentCursorPosition = getCursorOffset();

                // Skip processing if we just applied autocorrect
                if (justAppliedAutocorrect) {
                    justAppliedAutocorrect = false;
                    lastTextContent = currentTextContent;
                    lastTextLength = currentTextLength;
                    lastCursorPosition = currentCursorPosition;
                    autocorrectEnabled = true;
                    updateToolbarState();
                    debouncedAutocorrectCheck();
                    return;
                }

                // Calculate change in text length
                const textLengthChange = currentTextLength - lastTextLength;

                // Intelligent suppression logic for backspace
                if (textLengthChange < 0) {
                    // User is backspacing/deleting
                    // Check if we crossed over a delimiter using the OLD text and OLD cursor position
                    const wasAfterDelimiter = lastCursorPosition === 0 ||
                        (lastTextContent.length >= lastCursorPosition &&
                            /[\s,;.!?'"\/\-]/.test(lastTextContent[lastCursorPosition - 1]));
                    const isAfterDelimiter = isDelimiterBeforeCursor();

                    if (wasAfterDelimiter && !isAfterDelimiter) {
                        // We backspaced across a delimiter into an existing word
                        autocorrectEnabled = false;
                    } else if (!wasAfterDelimiter && !isAfterDelimiter) {
                        // We're still in the same word, keep current state
                    } else {
                        // Still after delimiter, keep enabled
                        autocorrectEnabled = true;
                    }
                } else if (textLengthChange > 0) {
                    // User is typing forward
                    // Check if we just typed a delimiter
                    const justTypedDelimiter = isDelimiterBeforeCursor();

                    if (justTypedDelimiter) {
                        // Just typed a delimiter - re-enable autocorrect
                        autocorrectEnabled = true;
                    }
                    // If already enabled, keep it enabled
                }

                lastTextContent = currentTextContent;
                lastTextLength = currentTextLength;
                lastCursorPosition = currentCursorPosition;
                updateToolbarState();
                debouncedAutocorrectCheck();
            });

            // Handle mouse clicks to check word boundary state
            editor.addEventListener('mousedown', function (e) {
                // After click, check if cursor landed after a delimiter
                setTimeout(() => {
                    autocorrectEnabled = isDelimiterBeforeCursor();
                }, 0);
            });

            // Track if we're in the middle of applying autocorrect (to block other inputs)
            let isApplyingAutocorrect = false;

            // Handle autocorrect application triggers and navigation keys
            editor.addEventListener('keydown', function (e) {
                // Block all input if we're currently applying autocorrect
                if (isApplyingAutocorrect) {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }

                // Check if this is a trigger key (space, Enter, or punctuation)
                const isEnter = e.key === 'Enter';
                const isSpace = e.key === ' ';
                const isPunctuation = [',', '.', ';', '/', '"', '?', '!'].includes(e.key);
                const isTriggerKey = isEnter || isSpace || isPunctuation;

                // If it's a trigger key, check for autocorrect BEFORE the key is processed
                if (isTriggerKey) {
                    // Get the current word BEFORE the space/punctuation is added
                    const currentWord = getCurrentWord();

                    // If there's no current suggestion but there's a current word, run full autocorrect check now
                    if (!currentAutocorrectSuggestion && currentWord && currentWord.length >= 3 && autocorrectEnabled) {
                        // Use findClosestWord for consistency - same logic whether typing fast or slow
                        const suggestion = editorAutocorrectEngine.findClosestWord(currentWord);

                        // Only set as suggestion if it's different from the current word
                        if (suggestion && suggestion.toLowerCase() !== currentWord.toLowerCase()) {
                            currentAutocorrectSuggestion = suggestion;
                            wordToReplaceWithSuggestion = currentWord;
                        }
                    }
                }

                // Re-enable autocorrect when typing whitespace (even if previously disabled)
                if (isSpace || isEnter) {
                    autocorrectEnabled = true;
                    justAppliedAutocorrect = false; // Clear the flag when typing whitespace
                }

                // Check for autocorrect application
                if (currentAutocorrectSuggestion && wordToReplaceWithSuggestion && isTriggerKey) {
                    // CRITICAL: Get the CURRENT word at trigger time, not the stored word
                    // The user may have continued typing after we showed the tooltip
                    const wordToDelete = getCurrentWord();
                    const suggestionToApply = currentAutocorrectSuggestion;

                    // Prevent the trigger key from being processed normally
                    e.preventDefault();
                    e.stopPropagation();

                    // Set flag to block other inputs during replacement
                    isApplyingAutocorrect = true;

                    // Use setTimeout to ensure this runs after any queued events
                    setTimeout(() => {
                        try {
                            // Replace the current word with autocorrect suggestion
                            if (wordToDelete) {
                                replaceCurrentWord(wordToDelete, suggestionToApply);
                                justAppliedAutocorrect = true;
                            }

                            // Hide tooltip and clear suggestion
                            hideAutocorrectTooltip();
                            currentAutocorrectSuggestion = null;
                            wordToReplaceWithSuggestion = null;

                            // Insert the trigger key that was prevented
                            if (e.key === 'Enter') {
                                // Insert line break using insertLineBreak for better contentEditable support
                                document.execCommand('insertLineBreak', false, null);
                            } else {
                                // For space and punctuation, insert the actual character
                                document.execCommand('insertText', false, e.key);
                            }
                        } finally {
                            // Always clear the flag, even if there's an error
                            isApplyingAutocorrect = false;
                        }
                    }, 0);

                    return false;
                }

                // Hide tooltip on navigation keys
                if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Home', 'End'].includes(e.key)) {
                    hideAutocorrectTooltip();
                    currentAutocorrectSuggestion = null;
                    wordToReplaceWithSuggestion = null;
                }
            });

            // Hide tooltip when clicking elsewhere
            document.addEventListener('click', function (e) {
                if (e.target !== editor) {
                    hideAutocorrectTooltip();
                }
            });

            // Save selection when editor loses focus (Quest 3 fix)
            let savedSelection = null;

            editor.addEventListener('blur', function () {
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    savedSelection = selection.getRangeAt(0).cloneRange();
                }
            });

            // Restore selection before dropdown interaction (Quest 3 fix)
            function restoreSavedSelection() {
                if (savedSelection) {
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(savedSelection);
                    return true;
                }
                return false;
            }

            // Initialize
            updateToolbarState();
            resizeTitleInput(); // Size the title input correctly on load
            resizeFontSizeSelector(); // Size the font size selector correctly on load

            // Set default font size to 13pt
            editor.style.fontSize = '13pt';

            // Focus the editor on page load so cursor is ready
            editor.focus();
        } // Close initializeEditor function
    </script>
</body>

</html>
