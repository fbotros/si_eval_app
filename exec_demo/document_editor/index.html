<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doc Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f9f9f9;
            min-height: 100vh;
        }

        .page-header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            padding: 28px 40px;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .page-title {
            text-align: left;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .page-title svg {
            width: 24px;
            height: 24px;
            flex-shrink: 0;
        }

        .document-title-container {
            position: relative;
            display: inline-flex;
            align-items: center;
        }

        .document-title-input {
            border: 1px solid transparent;
            background: transparent;
            padding: 6px 10px;
            font-size: 24px;
            font-weight: 400;
            color: #2d3748;
            margin: -7px -11px;
            outline: none;
            transition: all 0.2s ease;
            width: auto;
            min-width: 200px;
            border-radius: 6px;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .document-title-input:hover {
            border-color: rgba(0, 0, 0, 0.15);
            background: rgba(255, 255, 255, 0.5);
        }

        .document-title-input:focus {
            border-color: rgba(102, 126, 234, 0.4);
            background: rgba(255, 255, 255, 0.8);
        }

        .document-title-input:focus+.edit-icon {
            opacity: 0;
        }

        .edit-icon {
            width: 16px;
            height: 16px;
            opacity: 0.4;
            pointer-events: none;
            flex-shrink: 0;
            margin-left: 6px;
            transition: opacity 0.2s ease;
        }

        .main-content {
            display: flex;
            justify-content: center;
            padding: 40px 20px;
        }

        .container {
            width: 100%;
            max-width: 850px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 0;
            overflow: hidden;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .toolbar-header {
            background: #f5f5f5;
            padding: 2px 0;
            border-bottom: 1px solid #e3e3e3;
            position: sticky;
            top: 80px;
            z-index: 99;
        }

        .toolbar {
            max-width: 850px;
            margin: 0 auto;
            padding: 0 106px 0 0;
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .toolbar button {
            background: transparent;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: #4a5568;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 36px;
            height: 36px;
        }

        .toolbar button:hover {
            background: #e0e0e0;
        }

        .toolbar button.active {
            background: #d0d0d0;
            color: #2d3748;
        }

        .toolbar select {
            background: transparent;
            border: none;
            border-radius: 6px;
            padding: 8px 8px 8px 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: #4a5568;
            transition: background-color 0.2s ease;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            width: auto;
            padding-right: 24px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12"><path fill="%234a5568" d="M6 9L1 4h10z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 6px center;
        }

        .toolbar select:hover {
            background-color: #e0e0e0;
        }

        .toolbar select option {
            background: white;
            color: #2d3748;
        }

        .toolbar .separator {
            width: 1px;
            height: 24px;
            background: rgba(0, 0, 0, 0.1);
            margin: 0 8px;
        }

        #document-editor {
            min-height: 1000px;
            padding: 106px 106px 106px 106px;
            outline: none;
            font-size: 36pt;
            line-height: 1.7;
            color: #2d3748;
            background: transparent;
            border: none;
            font-family: Arial, sans-serif;
        }

        #document-editor:focus {
            outline: none;
        }


        /* Format styles for content */
        .bold {
            font-weight: bold;
        }

        .italic {
            font-style: italic;
        }

        .underline {
            text-decoration: underline;
        }

        .strikethrough {
            text-decoration: line-through;
        }

        /* Focus styles removed - keep consistent drop shadow */

        /* Autocorrect Tooltip - EXACT COPY from typing test modal */
        .autocorrect-tooltip {
            position: absolute;
            background: white;
            color: #333;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #3498db;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transform: translateY(-2px);
            transition: opacity 0.15s ease, transform 0.15s ease;
            white-space: nowrap;
            /* Match document editor font */
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 18px;
            font-weight: normal;
            line-height: 1.2;
        }

        .autocorrect-tooltip.show {
            opacity: 1;
            transform: translateY(0);
        }

        .autocorrect-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            right: 8px;
            border: 5px solid transparent;
            border-top-color: #3498db;
        }

        .autocorrect-tooltip::before {
            content: '';
            position: absolute;
            top: 100%;
            right: 8px;
            border: 6px solid transparent;
            border-top-color: white;
            margin-top: -1px;
        }
    </style>
</head>

<body>
    <div class="page-header">
        <h1 class="page-title">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M14 2H6C5.46957 2 4.96086 2.21071 4.58579 2.58579C4.21071 2.96086 4 3.46957 4 4V20C4 20.5304 4.21071 21.0391 4.58579 21.4142C4.96086 21.7893 5.46957 22 6 22H18C18.5304 22 19.0391 21.7893 19.4142 21.4142C19.7893 21.0391 20 20.5304 20 20V8L14 2Z"
                    stroke="#2d3748" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                <path d="M14 2V8H20" stroke="#2d3748" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                <path d="M16 13H8" stroke="#2d3748" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                <path d="M16 17H8" stroke="#2d3748" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                <path d="M10 9H9H8" stroke="#2d3748" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
            </svg>
            <div class="document-title-container">
                <input type="text" class="document-title-input" value="Untitled Document" id="document-title">
                <svg class="edit-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path
                        d="M17.2929 2.29291C17.6834 1.90238 18.3166 1.90238 18.7071 2.29291L21.7071 5.29291C22.0976 5.68343 22.0976 6.31659 21.7071 6.70712L8.70711 19.7071C8.51957 19.8947 8.26522 20 8 20H5C4.44772 20 4 19.5523 4 19V16C4 15.7348 4.10536 15.4804 4.29289 15.2929L17.2929 2.29291Z"
                        stroke="#9CA3AF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                    <path d="M15 5L19 9" stroke="#9CA3AF" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" />
                </svg>
            </div>
        </h1>
        <div style="position: absolute; top: 10px; right: 20px; font-size: 10px; color: #999; font-family: monospace; user-select: none;">
            v1.1.0-quest3
        </div>
    </div>

    <!-- Toolbar Header -->
    <div class="toolbar-header">
        <div class="toolbar">
            <button id="bold-btn" title="Bold (Ctrl+B)">B</button>
            <button id="italic-btn" title="Italic (Ctrl+I)"><em>I</em></button>
            <button id="underline-btn" title="Underline (Ctrl+U)"><u>U</u></button>
            <select id="font-size-selector" title="Font Size">
                <option value="9">9</option>
                <option value="11">11</option>
                <option value="12">12</option>
                <option value="16">16</option>
                <option value="18">18</option>
                <option value="24">24</option>
                <option value="36" selected>36</option>
            </select>
            <select id="font-selector" title="Font Family">
                <option value="Arial">Arial</option>
                <option value="Georgia">Georgia</option>
                <option value="Times New Roman">Times New Roman</option>
                <option value="Courier New">Courier New</option>
                <option value="Verdana">Verdana</option>
                <option value="Helvetica">Helvetica</option>
            </select>
        </div>
    </div>

    <div class="main-content">
        <div class="container">

            <!-- Document Editor -->
            <div id="document-editor" contenteditable="true" spellcheck="false" autocorrect="off" autocapitalize="off"
                autocomplete="off" data-gramm="false" data-gramm_editor="false" data-enable-grammarly="false"
                translate="no" data-ms-editor="false" data-lt-tmp-id="lt-0" data-lt-installed="false"
                data-grammarly-disable="true">
            </div>
        </div>
    </div>

    <!-- Autocorrect tooltip - positioned outside of contentEditable -->
    <div id="autocorrect-tooltip" class="autocorrect-tooltip"></div>

    <!-- Debug console for Quest 3 debugging -->
    <div id="debug-console" style="position: fixed; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.9); color: #0f0; font-family: monospace; font-size: 11px; max-height: 200px; overflow-y: auto; padding: 10px; z-index: 99999; display: none; border-top: 2px solid #0f0;">
      <div style="display: flex; justify-content: space-between; margin-bottom: 5px; border-bottom: 1px solid #0f0; padding-bottom: 5px;">
        <strong>Debug Console</strong>
        <button onclick="document.getElementById('debug-console').style.display='none'" style="background: #f00; color: #fff; border: none; padding: 2px 8px; cursor: pointer;">Close</button>
      </div>
      <div id="debug-output"></div>
    </div>
    <button id="debug-toggle" onclick="document.getElementById('debug-console').style.display='block'" style="position: fixed; bottom: 10px; right: 10px; z-index: 99998; background: #0f0; color: #000; border: 2px solid #000; padding: 5px 10px; font-weight: bold; cursor: pointer;">Show Debug</button>

    <!-- Load external scripts -->
    <script src="../dictionary-loader.js"></script>
    <script src="../AutocorrectEngine.js"></script>
    <script>
        // Debug logging function
        function debugLog(message, data) {
            const debugOutput = document.getElementById('debug-output');
            if (debugOutput) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.style.marginBottom = '3px';
                logEntry.style.borderBottom = '1px solid #333';
                logEntry.style.paddingBottom = '3px';

                let dataStr = '';
                if (data) {
                    try {
                        dataStr = ' | ' + JSON.stringify(data);
                    } catch (e) {
                        dataStr = ' | [circular data]';
                    }
                }

                logEntry.innerHTML = `<span style="color: #666">${timestamp}</span> ${message}${dataStr}`;
                debugOutput.insertBefore(logEntry, debugOutput.firstChild);

                // Keep only last 50 messages
                while (debugOutput.children.length > 50) {
                    debugOutput.removeChild(debugOutput.lastChild);
                }
            }
            console.log(message, data);
        }

        // Capture all errors
        window.onerror = function(msg, url, line, col, error) {
            debugLog('âŒ ERROR: ' + msg, {line, col, error: error?.stack});
            return false;
        };

        // Wait for DOM to be ready
        document.addEventListener('DOMContentLoaded', function () {
            initializeEditor();
        });

        function initializeEditor() {
            // Get DOM elements
            const editor = document.getElementById('document-editor');
            const titleInput = document.getElementById('document-title');

            if (!editor || !titleInput) {
                console.error('Required DOM elements not found');
                return;
            }

            // Formatting buttons
            const fontSelector = document.getElementById('font-selector');
            const fontSizeSelector = document.getElementById('font-size-selector');
            const boldBtn = document.getElementById('bold-btn');
            const italicBtn = document.getElementById('italic-btn');
            const underlineBtn = document.getElementById('underline-btn');

            // Initialize autocorrect engine
            let editorAutocorrectEngine = null;
            let autocorrectReady = false;

            // Global variable to store current autocorrect suggestion
            let currentAutocorrectSuggestion = null;
            let wordToReplaceWithSuggestion = null; // Store the word when we show suggestion

            // Initialize dictionary and autocorrect engine
            async function initializeAutocorrect() {
                try {
                    debugLog('ðŸ”„ Starting autocorrect initialization...');
                    const dictionary = await loadDictionary('../comprehensive_dictionary.txt');
                    debugLog('ðŸ“š Dictionary loaded', {wordCount: dictionary.length});

                    // Create autocorrect engine with dictionary words
                    editorAutocorrectEngine = new AutocorrectEngine();
                    editorAutocorrectEngine.addWords(dictionary);
                    autocorrectReady = true;
                    debugLog('âœ… Autocorrect engine ready!');
                } catch (error) {
                    debugLog('âŒ Failed to initialize autocorrect', {error: error.message, stack: error.stack});
                    console.error('âŒ Failed to initialize autocorrect:', error);
                }
            }

            // Start initialization
            debugLog('ðŸš€ Editor initialization started');
            initializeAutocorrect();

            // Format functions
            function toggleFormat(command) {
                document.execCommand(command, false, null);
                updateToolbarState();
                editor.focus();
            }

            function changeFont(fontName) {
                try {
                    debugLog('ðŸ”¤ changeFont called', {fontName});
                    const selection = window.getSelection();
                    debugLog('Selection state', {rangeCount: selection.rangeCount, collapsed: selection.rangeCount > 0 ? selection.getRangeAt(0).collapsed : null});

                    const hadSelection = selection.rangeCount > 0 && !selection.getRangeAt(0).collapsed;

                    document.execCommand('fontName', false, fontName);
                    debugLog('execCommand fontName executed');

                    // If there was a selection, restore it
                    if (hadSelection && selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        // Force the selection to remain visible
                        setTimeout(() => {
                            selection.removeAllRanges();
                            selection.addRange(range);
                            debugLog('Selection restored');
                        }, 0);
                    }

                    updateToolbarState();
                    resizeFontSelector();
                    editor.focus();
                    debugLog('âœ… changeFont complete');
                } catch (error) {
                    debugLog('âŒ ERROR in changeFont', {error: error.message, stack: error.stack});
                }
            }

            function changeFontSize(fontSize) {
                try {
                    debugLog('ðŸ“ changeFontSize called - USING execCommand like bold/italic', {fontSize});
                    
                    // Use the same approach as bold/italic/underline - just call execCommand!
                    // The fontSize command uses HTML size 1-7, but we can also wrap in font tags
                    // Or better: use inline style via execCommand
                    
                    // Save selection state for debugging
                    const selection = window.getSelection();
                    debugLog('Selection before execCommand', {
                        type: selection.type,
                        toString: selection.toString().substring(0, 20),
                        rangeCount: selection.rangeCount
                    });
                    
                    // Try using execCommand with fontSize (uses HTML size 1-7)
                    // Map our pt sizes to HTML sizes roughly
                    const htmlSizeMap = {
                        '9': '1',
                        '11': '2', 
                        '12': '3',
                        '16': '4',
                        '18': '5',
                        '24': '6',
                        '36': '7'
                    };
                    
                    const htmlSize = htmlSizeMap[fontSize] || '3';
                    document.execCommand('fontSize', false, htmlSize);
                    
                    debugLog('execCommand fontSize executed', {htmlSize});
                    
                    // Now convert the font tags to spans with pt sizes
                    setTimeout(() => {
                        const fontTags = editor.querySelectorAll('font[size]');
                        fontTags.forEach(fontTag => {
                            const size = fontTag.getAttribute('size');
                            // Find which fontSize this maps to
                            let ptSize = '11';
                            for (const [pt, html] of Object.entries(htmlSizeMap)) {
                                if (html === size) {
                                    ptSize = pt;
                                    break;
                                }
                            }
                            
                            const span = document.createElement('span');
                            span.style.fontSize = ptSize + 'pt';
                            while (fontTag.firstChild) {
                                span.appendChild(fontTag.firstChild);
                            }
                            fontTag.parentNode.replaceChild(span, fontTag);
                        });
                        debugLog('Converted font tags to span with pt sizes');
                    }, 0);
                    
                    updateToolbarState();
                    resizeFontSizeSelector();
                    editor.focus();
                    
                    debugLog('âœ… changeFontSize complete');
                } catch (error) {
                    debugLog('âŒ ERROR in changeFontSize', {error: error.message, stack: error.stack});
                }
            }

            // Auto-resize font selector to fit current selection
            function resizeFontSelector() {
                const selector = document.getElementById('font-selector');
                if (!selector) return;

                // Create a temporary span to measure text width
                const tempSpan = document.createElement('span');
                tempSpan.style.position = 'absolute';
                tempSpan.style.visibility = 'hidden';
                tempSpan.style.height = 'auto';
                tempSpan.style.width = 'auto';
                tempSpan.style.whiteSpace = 'nowrap';
                tempSpan.style.fontSize = '14px';
                tempSpan.style.fontWeight = '600';
                tempSpan.style.fontFamily = getComputedStyle(selector).fontFamily;
                tempSpan.textContent = selector.options[selector.selectedIndex].text;

                document.body.appendChild(tempSpan);
                const textWidth = tempSpan.offsetWidth;
                document.body.removeChild(tempSpan);

                // Set selector width to text width plus left padding (12px) + right padding for arrow (24px) + buffer (4px)
                selector.style.width = (textWidth + 40) + 'px';
            }

            // Auto-resize font size selector to fit current selection
            function resizeFontSizeSelector() {
                const selector = document.getElementById('font-size-selector');
                if (!selector) return;

                // Create a temporary span to measure text width
                const tempSpan = document.createElement('span');
                tempSpan.style.position = 'absolute';
                tempSpan.style.visibility = 'hidden';
                tempSpan.style.height = 'auto';
                tempSpan.style.width = 'auto';
                tempSpan.style.whiteSpace = 'nowrap';
                tempSpan.style.fontSize = '14px';
                tempSpan.style.fontWeight = '600';
                tempSpan.style.fontFamily = getComputedStyle(selector).fontFamily;
                tempSpan.textContent = selector.options[selector.selectedIndex].text;

                document.body.appendChild(tempSpan);
                const textWidth = tempSpan.offsetWidth;
                document.body.removeChild(tempSpan);

                // Set selector width to text width plus left padding (12px) + right padding for arrow (24px) + buffer (4px)
                selector.style.width = (textWidth + 40) + 'px';
            }

            function updateToolbarState() {
                boldBtn.classList.toggle('active', document.queryCommandState('bold'));
                italicBtn.classList.toggle('active', document.queryCommandState('italic'));
                underlineBtn.classList.toggle('active', document.queryCommandState('underline'));

                // Update font selector to reflect current font
                try {
                    const currentFont = document.queryCommandValue('fontName');
                    if (currentFont) {
                        // Clean up font name (remove quotes and extra formatting)
                        const cleanFont = currentFont.replace(/["']/g, '').split(',')[0].trim();
                        // Try to match with one of our options
                        const options = Array.from(fontSelector.options);
                        const matchingOption = options.find(opt =>
                            opt.value.toLowerCase() === cleanFont.toLowerCase()
                        );
                        if (matchingOption) {
                            fontSelector.value = matchingOption.value;
                            // Resize the dropdown to fit the new font selection
                            resizeFontSelector();
                        }
                    }
                } catch (e) {
                    // If queryCommandValue fails, just keep current selection
                }

                // Update font size selector to reflect current size
                try {
                    const selection = window.getSelection();
                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        let container = range.startContainer;
                        if (container.nodeType === Node.TEXT_NODE) {
                            container = container.parentElement;
                        }

                        // If container is the editor itself, check the previous sibling or last child
                        if (container === editor) {
                            // Look for the previous sibling element or the last child
                            if (range.startOffset > 0 && editor.childNodes[range.startOffset - 1]) {
                                // There's a previous element at this position
                                const prevNode = editor.childNodes[range.startOffset - 1];
                                // Skip tooltip elements
                                if (prevNode.nodeType === Node.ELEMENT_NODE &&
                                    !prevNode.classList.contains('autocorrect-tooltip')) {
                                    container = prevNode;
                                } else if (prevNode.nodeType === Node.TEXT_NODE && prevNode.parentElement) {
                                    container = prevNode.parentElement;
                                }
                            } else {
                                // Use the last child in the editor (skip tooltip)
                                let lastContentChild = null;
                                for (let i = editor.childNodes.length - 1; i >= 0; i--) {
                                    const node = editor.childNodes[i];
                                    if (node.nodeType === Node.ELEMENT_NODE &&
                                        !node.classList.contains('autocorrect-tooltip')) {
                                        lastContentChild = node;
                                        break;
                                    } else if (node.nodeType === Node.TEXT_NODE) {
                                        lastContentChild = node.parentElement;
                                        break;
                                    }
                                }
                                if (lastContentChild && lastContentChild !== editor) {
                                    container = lastContentChild;
                                }
                            }
                        }

                        if (container && container !== editor) {
                            const fontSize = window.getComputedStyle(container).fontSize;
                            // Convert px to pt (1pt = 1.333px approximately)
                            const fontSizePt = Math.round(parseFloat(fontSize) * 0.75);
                            // Try to match with one of our options
                            const sizeOptions = Array.from(fontSizeSelector.options);
                            const matchingSize = sizeOptions.find(opt =>
                                parseInt(opt.value) === fontSizePt
                            );
                            if (matchingSize) {
                                fontSizeSelector.value = matchingSize.value;
                                resizeFontSizeSelector();
                            }
                        }
                    }
                } catch (e) {
                    // If query fails, just keep current selection
                }
            }


            // Event listeners
            fontSizeSelector.addEventListener('change', (e) => {
                const beforeValue = e.target.value;
                const beforeIndex = e.target.selectedIndex;
                debugLog('ðŸ“ Font size dropdown CHANGE event fired', {value: beforeValue, selectedIndex: beforeIndex});
                
                changeFontSize(e.target.value);
                
                debugLog('ðŸ“ After changeFontSize, dropdown state:', {value: fontSizeSelector.value, selectedIndex: fontSizeSelector.selectedIndex});
                
                resizeFontSizeSelector();
                
                debugLog('ðŸ“ After resizeFontSizeSelector, dropdown state:', {value: fontSizeSelector.value, selectedIndex: fontSizeSelector.selectedIndex});
            });
            fontSelector.addEventListener('change', (e) => {
                debugLog('ðŸ”¤ Font family dropdown changed', {value: e.target.value, selectedIndex: e.target.selectedIndex});
                changeFont(e.target.value);
                resizeFontSelector();
            });

            // Additional debugging: log clicks on dropdowns
            fontSizeSelector.addEventListener('mousedown', () => {
                debugLog('ðŸ–±ï¸ Font size dropdown mousedown');
            });
            fontSizeSelector.addEventListener('focus', () => {
                debugLog('ðŸŽ¯ Font size dropdown focus');
            });
            fontSelector.addEventListener('mousedown', () => {
                debugLog('ðŸ–±ï¸ Font family dropdown mousedown');
            });
            fontSelector.addEventListener('focus', () => {
                debugLog('ðŸŽ¯ Font family dropdown focus');
            });
            boldBtn.addEventListener('click', () => toggleFormat('bold'));
            italicBtn.addEventListener('click', () => toggleFormat('italic'));
            underlineBtn.addEventListener('click', () => toggleFormat('underline'));

            // Keyboard shortcuts
            editor.addEventListener('keydown', function (e) {
                if (e.ctrlKey || e.metaKey) {
                    switch (e.key) {
                        case 'b':
                            e.preventDefault();
                            toggleFormat('bold');
                            break;
                        case 'i':
                            e.preventDefault();
                            toggleFormat('italic');
                            break;
                        case 'u':
                            e.preventDefault();
                            toggleFormat('underline');
                            break;
                        case 'z':
                            if (e.shiftKey) {
                                e.preventDefault();
                                document.execCommand('redo');
                            } else {
                                e.preventDefault();
                                document.execCommand('undo');
                            }
                            updateToolbarState();
                            break;
                        case 'y':
                            e.preventDefault();
                            document.execCommand('redo');
                            updateToolbarState();
                            break;
                    }
                }
            });

            // Update toolbar state on input
            editor.addEventListener('input', function () {
                updateToolbarState();
            });

            // Update toolbar state on selection change
            document.addEventListener('selectionchange', function () {
                if (document.activeElement === editor) {
                    updateToolbarState();
                }
            });

            // Focus editor on load
            editor.addEventListener('focus', function () {
                // Clear placeholder text on first focus
                if (editor.innerText === 'Start typing your document here...') {
                    editor.innerHTML = '';
                }
            });

            // Auto-resize title input to fit content
            function resizeTitleInput() {
                const input = document.getElementById('document-title');
                if (!input) return;

                // Create a temporary span to measure text width
                const tempSpan = document.createElement('span');
                tempSpan.style.position = 'absolute';
                tempSpan.style.visibility = 'hidden';
                tempSpan.style.height = 'auto';
                tempSpan.style.width = 'auto';
                tempSpan.style.whiteSpace = 'nowrap';
                tempSpan.style.fontSize = '24px';
                tempSpan.style.fontWeight = '400';
                tempSpan.style.fontFamily = getComputedStyle(input).fontFamily;
                tempSpan.textContent = input.value || input.placeholder || 'Untitled Document';

                document.body.appendChild(tempSpan);
                const textWidth = tempSpan.offsetWidth;
                document.body.removeChild(tempSpan);

                // Set input width to text width plus padding (20px) plus a bit of buffer (10px)
                input.style.width = (textWidth + 30) + 'px';
            }

            // Update input width on change
            titleInput.addEventListener('input', resizeTitleInput);
            titleInput.addEventListener('change', resizeTitleInput);

            // Select all text when clicking on the title input
            titleInput.addEventListener('click', function () {
                this.select();
            });

            // Also select all on focus (for keyboard navigation)
            titleInput.addEventListener('focus', function () {
                this.select();
            });

            // Tooltip management functions
            function showAutocorrectTooltip(text, x, y) {
                const tooltip = document.getElementById('autocorrect-tooltip');
                if (!tooltip) return;

                tooltip.textContent = text;
                tooltip.classList.remove('show');

                // Get the editor's position on the page
                const editorRect = editor.getBoundingClientRect();
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

                // Convert relative coordinates to absolute page coordinates
                const absoluteX = editorRect.left + scrollLeft + x;
                const absoluteY = editorRect.top + scrollTop + y;

                tooltip.style.position = 'absolute';
                tooltip.style.visibility = 'visible';
                tooltip.style.top = '0px';
                tooltip.style.left = '0px';

                // Force layout to get measurements
                const tooltipWidth = tooltip.offsetWidth;
                const tooltipHeight = tooltip.offsetHeight;

                // Position tooltip - align arrow (8px from right) with cursor, shifted 10px right
                let finalX = absoluteX - tooltipWidth + 8 + 10 - 3;
                let finalY = absoluteY;

                // Ensure tooltip doesn't go off screen edges
                const viewportWidth = window.innerWidth;
                if (finalX + tooltipWidth > viewportWidth - 10) {
                    finalX = viewportWidth - tooltipWidth - 10;
                }
                if (finalX < 10) {
                    finalX = 10;
                }
                if (finalY < 0) {
                    finalY = absoluteY + 30; // Position below cursor
                }

                tooltip.style.left = finalX + 'px';
                tooltip.style.top = finalY + 'px';
                tooltip.classList.add('show');
            }

            function hideAutocorrectTooltip() {
                const tooltip = document.getElementById('autocorrect-tooltip');
                if (tooltip) {
                    tooltip.classList.remove('show');
                    tooltip.style.visibility = 'hidden';
                }
            }

            // Get current word being typed
            function getCurrentWord() {
                if (!editorAutocorrectEngine) return '';

                const selection = window.getSelection();
                if (selection.rangeCount === 0) return '';

                try {
                    const range = selection.getRangeAt(0);

                    // Get FULL editor text using innerText (preserves newlines)
                    const fullEditorText = getEditorText();

                    // Calculate cursor position by matching what innerText does
                    let cursorPos = 0;
                    let foundCursor = false;

                    // Helper to recursively walk nodes and calculate position
                    function walkNodes(node, isFirstChild) {
                        if (foundCursor) return;

                        // If this is a text node
                        if (node.nodeType === Node.TEXT_NODE) {
                            if (node === range.startContainer) {
                                // Found the cursor - add only up to the offset
                                cursorPos += range.startOffset;
                                foundCursor = true;
                                return;
                            } else {
                                // Add full text length
                                cursorPos += node.textContent.length;
                            }
                        } else if (node.nodeType === Node.ELEMENT_NODE) {
                            // Check if this element creates a line break
                            if (node.nodeName === 'BR') {
                                cursorPos += 1; // BR = newline
                            } else if (node.nodeName === 'DIV' && node !== editor) {
                                // DIVs in contentEditable create line breaks
                                // But ONLY add newline if this isn't the first div AND it has content
                                if (!isFirstChild && cursorPos > 0) {
                                    cursorPos += 1;
                                }
                            }

                            // Walk through children
                            const children = Array.from(node.childNodes);
                            for (let i = 0; i < children.length; i++) {
                                walkNodes(children[i], i === 0 && isFirstChild);
                                if (foundCursor) break;
                            }
                        }
                    }

                    walkNodes(editor, true);

                    // Get text before cursor from full text
                    const textBeforeCursor = fullEditorText.substring(0, cursorPos);

                    // Extract word at end - stops at ANY whitespace including \n
                    const wordMatch = textBeforeCursor.match(/[\w']+$/);
                    const currentWord = wordMatch ? wordMatch[0] : '';

                    return currentWord;

                } catch (error) {
                    console.error('Error in getCurrentWord:', error);
                    return '';
                }
            }

            // Replace current word with autocorrect suggestion
            function replaceCurrentWord(wordToDelete, suggestion) {
                try {
                    const selection = window.getSelection();
                    if (selection.rangeCount === 0) return;

                    const range = selection.getRangeAt(0);

                    // Create a new range to select exactly the word we want to replace
                    const wordRange = document.createRange();

                    // Move the range start backwards by the word length
                    let startContainer = range.startContainer;
                    let startOffset = range.startOffset;

                    // Move backwards character by character to find the word start
                    let remainingChars = wordToDelete.length;

                    while (remainingChars > 0 && startContainer) {
                        if (startContainer.nodeType === Node.TEXT_NODE) {
                            const availableChars = startOffset;
                            const charsToTake = Math.min(remainingChars, availableChars);

                            startOffset -= charsToTake;
                            remainingChars -= charsToTake;

                            if (remainingChars > 0) {
                                // Need to go to previous text node
                                const walker = document.createTreeWalker(
                                    editor,
                                    NodeFilter.SHOW_TEXT,
                                    null,
                                    false
                                );
                                walker.currentNode = startContainer;
                                const prevNode = walker.previousNode();
                                if (prevNode) {
                                    startContainer = prevNode;
                                    startOffset = prevNode.textContent.length;
                                } else {
                                    break;
                                }
                            }
                        } else {
                            break;
                        }
                    }

                    // Set the range to select exactly the word
                    wordRange.setStart(startContainer, startOffset);
                    wordRange.setEnd(range.startContainer, range.startOffset);

                    // Verify we're selecting the right text
                    const selectedText = wordRange.toString();
                    if (selectedText === wordToDelete) {
                        // Select and replace the word
                        selection.removeAllRanges();
                        selection.addRange(wordRange);
                        document.execCommand('insertText', false, suggestion);

                        // Don't add extra space - trigger key will handle spacing
                    } else {
                        // Fallback to original method
                        for (let i = 0; i < wordToDelete.length; i++) {
                            document.execCommand('delete', false, null);
                        }
                        document.execCommand('insertText', false, suggestion);

                        // No extra space needed - trigger key will handle proper spacing
                    }

                } catch (error) {
                    console.error('âŒ Error replacing word:', error);
                    // Fallback to simple deletion method
                    try {
                        for (let i = 0; i < wordToDelete.length; i++) {
                            document.execCommand('delete', false, null);
                        }
                        document.execCommand('insertText', false, suggestion);
                    } catch (fallbackError) {
                        console.error('âŒ Fallback replacement also failed:', fallbackError);
                    }
                }
            }

            // Get cursor position for tooltip placement
            function getCursorPosition() {
                const selection = window.getSelection();
                if (selection.rangeCount === 0) return null;

                try {
                    const range = selection.getRangeAt(0);
                    const rect = range.getBoundingClientRect();

                    // Get editor bounds to calculate relative position
                    const editorRect = editor.getBoundingClientRect();

                    // Calculate position relative to the editor container
                    return {
                        x: rect.left - editorRect.left, // Relative to editor
                        y: rect.top - editorRect.top - 35 // Relative to editor, positioned above text
                    };
                } catch (error) {
                    return null;
                }
            }

            // Check if current word started at a word boundary (after whitespace)
            function isAtWordBoundary() {
                try {
                    const selection = window.getSelection();
                    if (selection.rangeCount === 0) return true;

                    const range = selection.getRangeAt(0);
                    let fullText = editor.innerText || '';
                    fullText = fullText.replace(/\n+$/, '');

                    // Calculate cursor position using the SAME logic as getCurrentWord
                    let cursorPos = 0;
                    if (range.startContainer === editor) {
                        const childNodes = Array.from(editor.childNodes);
                        for (let i = 0; i < Math.min(range.startOffset, childNodes.length); i++) {
                            const node = childNodes[i];
                            if (node.nodeType === Node.TEXT_NODE) {
                                cursorPos += node.textContent.length;
                            } else if (node.nodeType === Node.ELEMENT_NODE) {
                                cursorPos += node.innerText ? node.innerText.length : 0;
                            }
                        }
                    } else {
                        const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null, false);
                        let currentOffset = 0;
                        while (walker.nextNode()) {
                            const node = walker.currentNode;
                            if (node === range.startContainer) {
                                cursorPos = currentOffset + range.startOffset;
                                break;
                            }
                            currentOffset += node.textContent.length;
                        }
                    }

                    // Apply same cursor position fixes as getCurrentWord
                    if (cursorPos > fullText.length) {
                        cursorPos = fullText.length;
                    }

                    if (range.startContainer.nodeType === Node.TEXT_NODE &&
                        range.startOffset === range.startContainer.textContent.length) {
                        const nodeText = range.startContainer.textContent;
                        const expectedPos = fullText.lastIndexOf(nodeText);
                        if (expectedPos !== -1 && expectedPos + nodeText.length !== cursorPos) {
                            cursorPos = expectedPos + nodeText.length;
                        }
                    }

                    // Check if cursor is right after whitespace
                    if (cursorPos === 0) return true; // At start of document

                    const prevChar = fullText[cursorPos - 1];
                    return /\s/.test(prevChar); // True if cursor is right after whitespace
                } catch (error) {
                    return true; // Default to allow if error
                }
            }

            // Helper to get text - use innerText which preserves newlines from contentEditable
            function getEditorText() {
                // innerText respects the visual layout and newlines
                let text = editor.innerText || '';

                // Strip only trailing newlines (contentEditable adds these at end)
                text = text.replace(/\n+$/, '');

                return text;
            }

            // Track autocorrect state - intelligent suppression approach
            let autocorrectEnabled = true;
            let justAppliedAutocorrect = false;
            let lastTextLength = 0;
            let lastCursorPosition = 0;
            let lastTextContent = ''; // Track the actual text content
            
            // Track pending font size for Quest 3 compatibility
            let pendingFontSize = '11'; // Default

            // Helper to check if the character before cursor is a delimiter (whitespace/punctuation)
            function isDelimiterBeforeCursor() {
                try {
                    const fullText = getEditorText();
                    const cursorPos = getCursorOffset();

                    // At start of document = delimiter boundary
                    if (cursorPos === 0) return true;

                    // Check character before cursor
                    const charBeforeCursor = fullText[cursorPos - 1];

                    // Whitespace or punctuation = delimiter
                    return /[\s,;.!?'"\/\-]/.test(charBeforeCursor);
                } catch (error) {
                    return true; // Default to safe state
                }
            }

            // Check for autocorrect suggestions
            function checkForAutocorrect() {
                if (!editorAutocorrectEngine || !autocorrectReady) {
                    return;
                }

                const currentWord = getCurrentWord();

                // If autocorrect is disabled, check if we should re-enable it
                if (!autocorrectEnabled) {
                    if (currentWord.length === 0 || isDelimiterBeforeCursor()) {
                        autocorrectEnabled = true;
                    } else {
                        currentAutocorrectSuggestion = null;
                        hideAutocorrectTooltip();
                        return;
                    }
                }

                if (currentWord.length < 3) {
                    currentAutocorrectSuggestion = null;
                    hideAutocorrectTooltip();
                    return;
                }

                // Check if possessive form is valid (base word exists in dictionary)
                if (currentWord.endsWith("'s")) {
                    const baseWord = currentWord.slice(0, -2); // Remove 's
                    if (editorAutocorrectEngine.dictionarySet && editorAutocorrectEngine.dictionarySet.has(baseWord.toLowerCase())) {
                        currentAutocorrectSuggestion = null;
                        hideAutocorrectTooltip();
                        return;
                    }
                }

                // Check if word is capitalized (for preserving capitalization in suggestions)
                const isCapitalized = currentWord[0] === currentWord[0].toUpperCase() && currentWord.length > 1;

                // Create lowercase version for dictionary lookup
                const wordForLookup = isCapitalized ? currentWord.toLowerCase() : currentWord;

                // Check for override corrections first
                const lowerWord = currentWord.toLowerCase();

                if (editorAutocorrectEngine.correctionOverrides && editorAutocorrectEngine.correctionOverrides[lowerWord]) {
                    const suggestion = editorAutocorrectEngine.correctionOverrides[lowerWord];
                    currentAutocorrectSuggestion = suggestion;
                    wordToReplaceWithSuggestion = currentWord;

                    const cursorPos = getCursorPosition();
                    if (cursorPos) {
                        showAutocorrectTooltip(suggestion, cursorPos.x, cursorPos.y);
                    }
                    return;
                }


                // Test word splitting approach first (using lowercase for lookup)
                if (editorAutocorrectEngine.findTwoWordSplit) {
                    const twoWordSplit = editorAutocorrectEngine.findTwoWordSplit(wordForLookup);

                    if (twoWordSplit && twoWordSplit !== wordForLookup) {
                        // Capitalize suggestion if original word was capitalized
                        let finalSuggestion = twoWordSplit;
                        if (isCapitalized && twoWordSplit.length > 0) {
                            finalSuggestion = twoWordSplit.charAt(0).toUpperCase() + twoWordSplit.slice(1);
                        }

                        currentAutocorrectSuggestion = finalSuggestion;
                        wordToReplaceWithSuggestion = currentWord;

                        const cursorPos = getCursorPosition();
                        if (cursorPos) {
                            showAutocorrectTooltip(finalSuggestion, cursorPos.x, cursorPos.y);
                            return;
                        }
                    }
                }

                // For regular words, use findClosestWord (using lowercase for lookup)
                const suggestion = editorAutocorrectEngine.findClosestWord(wordForLookup);

                // Show tooltip if suggestion is different from original input
                if (suggestion && suggestion !== wordForLookup && suggestion !== currentWord.toLowerCase()) {
                    // Capitalize suggestion if original word was capitalized
                    let finalSuggestion = suggestion;
                    if (isCapitalized && suggestion.length > 0) {
                        finalSuggestion = suggestion.charAt(0).toUpperCase() + suggestion.slice(1);
                    }

                    currentAutocorrectSuggestion = finalSuggestion;
                    wordToReplaceWithSuggestion = currentWord;

                    const cursorPos = getCursorPosition();
                    if (cursorPos) {
                        showAutocorrectTooltip(finalSuggestion, cursorPos.x, cursorPos.y);
                    }
                } else {
                    currentAutocorrectSuggestion = null;
                    wordToReplaceWithSuggestion = null;
                    hideAutocorrectTooltip();
                }
            }

            // Debounced autocorrect check
            let autocorrectTimeout;
            function debouncedAutocorrectCheck() {
                clearTimeout(autocorrectTimeout);
                autocorrectTimeout = setTimeout(checkForAutocorrect, 200);
            }

            // Track last typed key to detect space/punctuation
            let lastTypedKey = '';

            // Add keydown listener to track what key was pressed
            editor.addEventListener('keydown', function (e) {
                lastTypedKey = e.key;
            });

            // Helper to get cursor offset in text - uses SAME node-walking logic as getCurrentWord
            function getCursorOffset() {
                const selection = window.getSelection();
                if (!selection.rangeCount) return 0;

                const range = selection.getRangeAt(0);

                // Calculate cursor position by walking through the editor's text nodes
                // This is the SAME logic used in getCurrentWord()
                let cursorPos = 0;
                let foundCursor = false;

                function walkNodes(node) {
                    if (foundCursor) return;

                    // If this is a text node
                    if (node.nodeType === Node.TEXT_NODE) {
                        if (node === range.startContainer) {
                            // Found the cursor - add only up to the offset
                            cursorPos += range.startOffset;
                            foundCursor = true;
                            return;
                        } else {
                            // Add full text length
                            cursorPos += node.textContent.length;
                        }
                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                        // Check if this element is a BR or creates a line break
                        if (node.nodeName === 'BR') {
                            cursorPos += 1; // BR = newline
                        } else if (node.nodeName === 'DIV' && node !== editor) {
                            // DIVs in contentEditable create line breaks (except the root editor)
                            const childNodes = Array.from(node.childNodes);
                            if (childNodes.length > 0) {
                                // Add newline before the div's content (if not first div)
                                if (cursorPos > 0) {
                                    cursorPos += 1;
                                }
                            }
                        }

                        // Walk through children
                        for (const child of node.childNodes) {
                            walkNodes(child);
                            if (foundCursor) break;
                        }
                    }
                }

                walkNodes(editor);
                return cursorPos;
            }


            // Helper to get consistent text length (matching what getCurrentWord uses)
            function getConsistentTextLength() {
                return getEditorText().length;
            }

            // Add input listener for autocorrect tooltips (suggestion-only)
            editor.addEventListener('input', function (e) {
                const currentTextContent = getEditorText();
                const currentTextLength = currentTextContent.length;
                const currentCursorPosition = getCursorOffset();

                // Skip processing if we just applied autocorrect
                if (justAppliedAutocorrect) {
                    justAppliedAutocorrect = false;
                    lastTextContent = currentTextContent;
                    lastTextLength = currentTextLength;
                    lastCursorPosition = currentCursorPosition;
                    autocorrectEnabled = true;
                    updateToolbarState();
                    debouncedAutocorrectCheck();
                    return;
                }

                // Calculate change in text length
                const textLengthChange = currentTextLength - lastTextLength;

                // Intelligent suppression logic for backspace
                if (textLengthChange < 0) {
                    // User is backspacing/deleting
                    // Check if we crossed over a delimiter using the OLD text and OLD cursor position
                    const wasAfterDelimiter = lastCursorPosition === 0 ||
                        (lastTextContent.length >= lastCursorPosition &&
                            /[\s,;.!?'"\/\-]/.test(lastTextContent[lastCursorPosition - 1]));
                    const isAfterDelimiter = isDelimiterBeforeCursor();

                    if (wasAfterDelimiter && !isAfterDelimiter) {
                        // We backspaced across a delimiter into an existing word
                        autocorrectEnabled = false;
                    } else if (!wasAfterDelimiter && !isAfterDelimiter) {
                        // We're still in the same word, keep current state
                    } else {
                        // Still after delimiter, keep enabled
                        autocorrectEnabled = true;
                    }
                } else if (textLengthChange > 0) {
                    // User is typing forward
                    // Check if we just typed a delimiter
                    const justTypedDelimiter = isDelimiterBeforeCursor();

                    if (justTypedDelimiter) {
                        // Just typed a delimiter - re-enable autocorrect
                        autocorrectEnabled = true;
                    }
                    // If already enabled, keep it enabled
                }

                lastTextContent = currentTextContent;
                lastTextLength = currentTextLength;
                lastCursorPosition = currentCursorPosition;
                updateToolbarState();
                debouncedAutocorrectCheck();
            });

            // Handle mouse clicks to check word boundary state
            editor.addEventListener('mousedown', function (e) {
                // After click, check if cursor landed after a delimiter
                setTimeout(() => {
                    autocorrectEnabled = isDelimiterBeforeCursor();
                }, 0);
            });

            // Track if we're in the middle of applying autocorrect (to block other inputs)
            let isApplyingAutocorrect = false;

            // Handle autocorrect application triggers and navigation keys
            editor.addEventListener('keydown', function (e) {
                // Block all input if we're currently applying autocorrect
                if (isApplyingAutocorrect) {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }

                // Check if this is a trigger key (space, Enter, or punctuation)
                const isEnter = e.key === 'Enter';
                const isSpace = e.key === ' ';
                const isPunctuation = [',', '.', ';', '/', '"', "'", '?', '!'].includes(e.key);
                const isTriggerKey = isEnter || isSpace || isPunctuation;

                // If it's a trigger key, check for autocorrect BEFORE the key is processed
                if (isTriggerKey) {
                    // Get the current word BEFORE the space/punctuation is added
                    const currentWord = getCurrentWord();

                    // If there's no current suggestion but there's a current word, run full autocorrect check now
                    if (!currentAutocorrectSuggestion && currentWord && currentWord.length >= 3 && autocorrectEnabled) {
                        const lowerWord = currentWord.toLowerCase();

                        // Check overrides first
                        if (editorAutocorrectEngine.correctionOverrides &&
                            editorAutocorrectEngine.correctionOverrides[lowerWord]) {
                            const suggestion = editorAutocorrectEngine.correctionOverrides[lowerWord];
                            currentAutocorrectSuggestion = suggestion;
                            wordToReplaceWithSuggestion = currentWord;
                        }
                        // Check for two-word split
                        else if (editorAutocorrectEngine.findTwoWordSplit) {
                            const twoWordSplit = editorAutocorrectEngine.findTwoWordSplit(lowerWord);
                            if (twoWordSplit && twoWordSplit !== lowerWord) {
                                // Capitalize if original was capitalized
                                const isCapitalized = currentWord[0] === currentWord[0].toUpperCase();
                                const finalSuggestion = isCapitalized && twoWordSplit.length > 0
                                    ? twoWordSplit.charAt(0).toUpperCase() + twoWordSplit.slice(1)
                                    : twoWordSplit;

                                currentAutocorrectSuggestion = finalSuggestion;
                                wordToReplaceWithSuggestion = currentWord;
                            }
                        }
                    }
                }

                // Re-enable autocorrect when typing whitespace (even if previously disabled)
                if (isSpace || isEnter) {
                    autocorrectEnabled = true;
                    justAppliedAutocorrect = false; // Clear the flag when typing whitespace
                }

                // Check for autocorrect application
                if (currentAutocorrectSuggestion && wordToReplaceWithSuggestion && isTriggerKey) {
                    // Use the stored word that we showed in the tooltip
                    const wordToDelete = wordToReplaceWithSuggestion;
                    const suggestionToApply = currentAutocorrectSuggestion;

                    // Prevent the trigger key from being processed normally
                    e.preventDefault();
                    e.stopPropagation();

                    // Set flag to block other inputs during replacement
                    isApplyingAutocorrect = true;

                    // Use setTimeout to ensure this runs after any queued events
                    setTimeout(() => {
                        try {
                            // Replace the current word with autocorrect suggestion
                            if (wordToDelete) {
                                replaceCurrentWord(wordToDelete, suggestionToApply);
                                justAppliedAutocorrect = true;
                            }

                            // Hide tooltip and clear suggestion
                            hideAutocorrectTooltip();
                            currentAutocorrectSuggestion = null;
                            wordToReplaceWithSuggestion = null;

                            // Insert the trigger key that was prevented
                            if (e.key === 'Enter') {
                                // Insert line break using insertLineBreak for better contentEditable support
                                document.execCommand('insertLineBreak', false, null);
                            } else {
                                // For space and punctuation, insert the actual character
                                document.execCommand('insertText', false, e.key);
                            }
                        } finally {
                            // Always clear the flag, even if there's an error
                            isApplyingAutocorrect = false;
                        }
                    }, 0);

                    return false;
                }

                // Hide tooltip on navigation keys
                if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Home', 'End'].includes(e.key)) {
                    hideAutocorrectTooltip();
                    currentAutocorrectSuggestion = null;
                    wordToReplaceWithSuggestion = null;
                }
            });

            // Hide tooltip when clicking elsewhere
            document.addEventListener('click', function (e) {
                if (e.target !== editor) {
                    hideAutocorrectTooltip();
                }
            });

            // Initialize
            updateToolbarState();
            resizeTitleInput(); // Size the title input correctly on load
            resizeFontSizeSelector(); // Size the font size selector correctly on load
            resizeFontSelector(); // Size the font selector correctly on load

            // Set default font size to 36pt for Quest 3 debugging
            editor.style.fontSize = '36pt';
            debugLog('ðŸŽ¯ Default font size set to 36pt for debugging');

            // Focus the editor on page load so cursor is ready
            editor.focus();
        } // Close initializeEditor function
    </script>
</body>

</html>
