<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doc Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f9f9f9;
            min-height: 100vh;
        }

        .page-header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            padding: 28px 40px;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .page-title {
            text-align: left;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .page-title svg {
            width: 24px;
            height: 24px;
            flex-shrink: 0;
        }

        .document-title-container {
            position: relative;
            display: inline-flex;
            align-items: center;
        }

        .document-title-input {
            border: 1px solid transparent;
            background: transparent;
            padding: 6px 10px;
            font-size: 24px;
            font-weight: 400;
            color: #2d3748;
            margin: -7px -11px;
            outline: none;
            transition: all 0.2s ease;
            width: auto;
            min-width: 200px;
            border-radius: 6px;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .document-title-input:hover {
            border-color: rgba(0, 0, 0, 0.15);
            background: rgba(255, 255, 255, 0.5);
        }

        .document-title-input:focus {
            border-color: rgba(102, 126, 234, 0.4);
            background: rgba(255, 255, 255, 0.8);
        }

        .document-title-input:focus+.edit-icon {
            opacity: 0;
        }

        .edit-icon {
            width: 16px;
            height: 16px;
            opacity: 0.4;
            pointer-events: none;
            flex-shrink: 0;
            margin-left: 6px;
            transition: opacity 0.2s ease;
        }

        .main-content {
            display: flex;
            justify-content: center;
            padding: 40px 20px;
        }

        .container {
            width: 100%;
            max-width: 850px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 0;
            overflow: hidden;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .toolbar-header {
            background: #f5f5f5;
            padding: 2px 0;
            border-bottom: 1px solid #e3e3e3;
            position: sticky;
            top: 80px;
            z-index: 99;
        }

        .toolbar {
            max-width: 850px;
            margin: 0 auto;
            padding: 0 106px 0 0;
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .toolbar button {
            background: transparent;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: #4a5568;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 36px;
            height: 36px;
        }

        .toolbar button:hover {
            background: #e0e0e0;
        }

        .toolbar button.active {
            background: #d0d0d0;
            color: #2d3748;
        }

        .toolbar select {
            background: transparent;
            border: none;
            border-radius: 6px;
            padding: 8px 8px 8px 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: #4a5568;
            transition: background-color 0.2s ease;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            width: auto;
            padding-right: 24px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12"><path fill="%234a5568" d="M6 9L1 4h10z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 6px center;
        }

        .toolbar select:hover {
            background-color: #e0e0e0;
        }

        .toolbar select option {
            background: white;
            color: #2d3748;
        }

        .toolbar .separator {
            width: 1px;
            height: 24px;
            background: rgba(0, 0, 0, 0.1);
            margin: 0 8px;
        }

        #document-editor {
            min-height: 1000px;
            padding: 106px 106px 106px 106px;
            outline: none;
            font-size: 11pt;
            line-height: 1.7;
            color: #2d3748;
            background: transparent;
            border: none;
            font-family: Arial, sans-serif;
        }

        #document-editor:focus {
            outline: none;
        }


        /* Format styles for content */
        .bold {
            font-weight: bold;
        }

        .italic {
            font-style: italic;
        }

        .underline {
            text-decoration: underline;
        }

        .strikethrough {
            text-decoration: line-through;
        }

        /* Focus styles removed - keep consistent drop shadow */

        /* Autocorrect Tooltip - EXACT COPY from typing test modal */
        .autocorrect-tooltip {
            position: absolute;
            background: white;
            color: #333;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #3498db;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transform: translateY(-2px);
            transition: opacity 0.15s ease, transform 0.15s ease;
            white-space: nowrap;
            /* Match document editor font */
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 18px;
            font-weight: normal;
            line-height: 1.2;
        }

        .autocorrect-tooltip.show {
            opacity: 1;
            transform: translateY(0);
        }

        .autocorrect-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            right: 8px;
            border: 5px solid transparent;
            border-top-color: #3498db;
        }

        .autocorrect-tooltip::before {
            content: '';
            position: absolute;
            top: 100%;
            right: 8px;
            border: 6px solid transparent;
            border-top-color: white;
            margin-top: -1px;
        }
    </style>
</head>

<body>
    <div class="page-header">
        <h1 class="page-title">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M14 2H6C5.46957 2 4.96086 2.21071 4.58579 2.58579C4.21071 2.96086 4 3.46957 4 4V20C4 20.5304 4.21071 21.0391 4.58579 21.4142C4.96086 21.7893 5.46957 22 6 22H18C18.5304 22 19.0391 21.7893 19.4142 21.4142C19.7893 21.0391 20 20.5304 20 20V8L14 2Z" stroke="#2d3748" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M14 2V8H20" stroke="#2d3748" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M16 13H8" stroke="#2d3748" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M16 17H8" stroke="#2d3748" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M10 9H9H8" stroke="#2d3748" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <div class="document-title-container">
                <input type="text" class="document-title-input" value="Untitled Document" id="document-title">
                <svg class="edit-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path
                        d="M17.2929 2.29291C17.6834 1.90238 18.3166 1.90238 18.7071 2.29291L21.7071 5.29291C22.0976 5.68343 22.0976 6.31659 21.7071 6.70712L8.70711 19.7071C8.51957 19.8947 8.26522 20 8 20H5C4.44772 20 4 19.5523 4 19V16C4 15.7348 4.10536 15.4804 4.29289 15.2929L17.2929 2.29291Z"
                        stroke="#9CA3AF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                    <path d="M15 5L19 9" stroke="#9CA3AF" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" />
                </svg>
            </div>
        </h1>
    </div>

    <!-- Toolbar Header -->
    <div class="toolbar-header">
        <div class="toolbar">
            <button id="bold-btn" title="Bold (Ctrl+B)">B</button>
            <button id="italic-btn" title="Italic (Ctrl+I)"><em>I</em></button>
            <button id="underline-btn" title="Underline (Ctrl+U)"><u>U</u></button>
            <select id="font-size-selector" title="Font Size">
                <option value="8">8</option>
                <option value="9">9</option>
                <option value="10">10</option>
                <option value="11" selected>11</option>
                <option value="12">12</option>
                <option value="14">14</option>
                <option value="16">16</option>
                <option value="18">18</option>
                <option value="20">20</option>
                <option value="22">22</option>
                <option value="24">24</option>
                <option value="26">26</option>
                <option value="30">30</option>
                <option value="36">36</option>
            </select>
            <select id="font-selector" title="Font Family">
                <option value="Arial">Arial</option>
                <option value="Georgia">Georgia</option>
                <option value="Times New Roman">Times New Roman</option>
                <option value="Courier New">Courier New</option>
                <option value="Verdana">Verdana</option>
                <option value="Helvetica">Helvetica</option>
            </select>
        </div>
    </div>

    <div class="main-content">
        <div class="container">

            <!-- Document Editor -->
            <div id="document-editor"
                 contenteditable="true"
                 spellcheck="false"
                 autocorrect="off"
                 autocapitalize="off"
                 autocomplete="off"
                 data-gramm="false"
                 data-gramm_editor="false"
                 data-enable-grammarly="false"
                 translate="no"
                 data-ms-editor="false"
                 data-lt-tmp-id="lt-0"
                 data-lt-installed="false"
                 data-grammarly-disable="true"
                 style="-webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none;">
            </div>
        </div>
    </div>

    <!-- Load external scripts -->
    <script src="../dictionary-loader.js"></script>
    <script src="../AutocorrectEngine.js"></script>
    <script>
        // Wait for DOM to be ready
        document.addEventListener('DOMContentLoaded', function() {
            initializeEditor();
        });

        function initializeEditor() {
            // Get DOM elements
            const editor = document.getElementById('document-editor');
            const titleInput = document.getElementById('document-title');

            if (!editor || !titleInput) {
                console.error('Required DOM elements not found');
                return;
            }

        // Formatting buttons
        const fontSelector = document.getElementById('font-selector');
        const fontSizeSelector = document.getElementById('font-size-selector');
        const boldBtn = document.getElementById('bold-btn');
        const italicBtn = document.getElementById('italic-btn');
        const underlineBtn = document.getElementById('underline-btn');

        // Initialize autocorrect engine
        let editorAutocorrectEngine = null;

        // Global variable to store current autocorrect suggestion
        let currentAutocorrectSuggestion = null;

        // Initialize dictionary and autocorrect engine
        async function initializeAutocorrect() {
            try {
                const dictionary = await loadDictionary('../comprehensive_dictionary.txt');

                // Create autocorrect engine with dictionary words
                editorAutocorrectEngine = new AutocorrectEngine();
                editorAutocorrectEngine.addWords(dictionary);
            } catch (error) {
                console.error('‚ùå Failed to initialize autocorrect:', error);
            }
        }

        // Start initialization
        initializeAutocorrect();

        // Format functions
        function toggleFormat(command) {
            document.execCommand(command, false, null);
            updateToolbarState();
            editor.focus();
        }

        function changeFont(fontName) {
            document.execCommand('fontName', false, fontName);
            updateToolbarState();
            resizeFontSelector();
            editor.focus();
        }

        function changeFontSize(fontSize) {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);

                // Check if there's selected text
                if (!range.collapsed) {
                    // Text is selected - apply font size to selection
                    const selectedContent = range.extractContents();
                    const span = document.createElement('span');
                    span.style.fontSize = fontSize + 'pt';
                    span.appendChild(selectedContent);
                    range.insertNode(span);
                    // Move cursor to end of inserted content
                    range.collapse(false);
                    selection.removeAllRanges();
                    selection.addRange(range);
                } else {
                    // No text selected - insert a styled span for upcoming text
                    const span = document.createElement('span');
                    span.style.fontSize = fontSize + 'pt';
                    // Insert a zero-width space to make the span "stick"
                    span.appendChild(document.createTextNode('\u200B'));
                    range.insertNode(span);
                    // Place cursor inside the span after the zero-width space
                    range.setStart(span.firstChild, 1);
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
            }
            updateToolbarState();
            resizeFontSizeSelector();
            editor.focus();
        }

        // Auto-resize font selector to fit current selection
        function resizeFontSelector() {
            const selector = document.getElementById('font-selector');
            if (!selector) return;

            // Create a temporary span to measure text width
            const tempSpan = document.createElement('span');
            tempSpan.style.position = 'absolute';
            tempSpan.style.visibility = 'hidden';
            tempSpan.style.height = 'auto';
            tempSpan.style.width = 'auto';
            tempSpan.style.whiteSpace = 'nowrap';
            tempSpan.style.fontSize = '14px';
            tempSpan.style.fontWeight = '600';
            tempSpan.style.fontFamily = getComputedStyle(selector).fontFamily;
            tempSpan.textContent = selector.options[selector.selectedIndex].text;

            document.body.appendChild(tempSpan);
            const textWidth = tempSpan.offsetWidth;
            document.body.removeChild(tempSpan);

            // Set selector width to text width plus left padding (12px) + right padding for arrow (24px) + buffer (4px)
            selector.style.width = (textWidth + 40) + 'px';
        }

        // Auto-resize font size selector to fit current selection
        function resizeFontSizeSelector() {
            const selector = document.getElementById('font-size-selector');
            if (!selector) return;

            // Create a temporary span to measure text width
            const tempSpan = document.createElement('span');
            tempSpan.style.position = 'absolute';
            tempSpan.style.visibility = 'hidden';
            tempSpan.style.height = 'auto';
            tempSpan.style.width = 'auto';
            tempSpan.style.whiteSpace = 'nowrap';
            tempSpan.style.fontSize = '14px';
            tempSpan.style.fontWeight = '600';
            tempSpan.style.fontFamily = getComputedStyle(selector).fontFamily;
            tempSpan.textContent = selector.options[selector.selectedIndex].text;

            document.body.appendChild(tempSpan);
            const textWidth = tempSpan.offsetWidth;
            document.body.removeChild(tempSpan);

            // Set selector width to text width plus left padding (12px) + right padding for arrow (24px) + buffer (4px)
            selector.style.width = (textWidth + 40) + 'px';
        }

        function updateToolbarState() {
            boldBtn.classList.toggle('active', document.queryCommandState('bold'));
            italicBtn.classList.toggle('active', document.queryCommandState('italic'));
            underlineBtn.classList.toggle('active', document.queryCommandState('underline'));

            // Update font selector to reflect current font
            try {
                const currentFont = document.queryCommandValue('fontName');
                if (currentFont) {
                    // Clean up font name (remove quotes and extra formatting)
                    const cleanFont = currentFont.replace(/["']/g, '').split(',')[0].trim();
                    // Try to match with one of our options
                    const options = Array.from(fontSelector.options);
                    const matchingOption = options.find(opt =>
                        opt.value.toLowerCase() === cleanFont.toLowerCase()
                    );
                    if (matchingOption) {
                        fontSelector.value = matchingOption.value;
                        // Resize the dropdown to fit the new font selection
                        resizeFontSelector();
                    }
                }
            } catch (e) {
                // If queryCommandValue fails, just keep current selection
            }

            // Update font size selector to reflect current size
            try {
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    let container = range.startContainer;
                    if (container.nodeType === Node.TEXT_NODE) {
                        container = container.parentElement;
                    }

                    // If container is the editor itself, check the previous sibling or last child
                    if (container === editor) {
                        // Look for the previous sibling element or the last child
                        if (range.startOffset > 0 && editor.childNodes[range.startOffset - 1]) {
                            // There's a previous element at this position
                            const prevNode = editor.childNodes[range.startOffset - 1];
                            // Skip tooltip elements
                            if (prevNode.nodeType === Node.ELEMENT_NODE &&
                                !prevNode.classList.contains('autocorrect-tooltip')) {
                                container = prevNode;
                            } else if (prevNode.nodeType === Node.TEXT_NODE && prevNode.parentElement) {
                                container = prevNode.parentElement;
                            }
                        } else {
                            // Use the last child in the editor (skip tooltip)
                            let lastContentChild = null;
                            for (let i = editor.childNodes.length - 1; i >= 0; i--) {
                                const node = editor.childNodes[i];
                                if (node.nodeType === Node.ELEMENT_NODE &&
                                    !node.classList.contains('autocorrect-tooltip')) {
                                    lastContentChild = node;
                                    break;
                                } else if (node.nodeType === Node.TEXT_NODE) {
                                    lastContentChild = node.parentElement;
                                    break;
                                }
                            }
                            if (lastContentChild && lastContentChild !== editor) {
                                container = lastContentChild;
                            }
                        }
                    }

                    if (container && container !== editor) {
                        const fontSize = window.getComputedStyle(container).fontSize;
                        // Convert px to pt (1pt = 1.333px approximately)
                        const fontSizePt = Math.round(parseFloat(fontSize) * 0.75);
                        // Try to match with one of our options
                        const sizeOptions = Array.from(fontSizeSelector.options);
                        const matchingSize = sizeOptions.find(opt =>
                            parseInt(opt.value) === fontSizePt
                        );
                        if (matchingSize) {
                            fontSizeSelector.value = matchingSize.value;
                            resizeFontSizeSelector();
                        }
                    }
                }
            } catch (e) {
                // If query fails, just keep current selection
            }
        }


        // Event listeners
        fontSizeSelector.addEventListener('change', (e) => {
            changeFontSize(e.target.value);
            resizeFontSizeSelector();
        });
        fontSelector.addEventListener('change', (e) => {
            changeFont(e.target.value);
            resizeFontSelector();
        });
        boldBtn.addEventListener('click', () => toggleFormat('bold'));
        italicBtn.addEventListener('click', () => toggleFormat('italic'));
        underlineBtn.addEventListener('click', () => toggleFormat('underline'));

        // Keyboard shortcuts
        editor.addEventListener('keydown', function (e) {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 'b':
                        e.preventDefault();
                        toggleFormat('bold');
                        break;
                    case 'i':
                        e.preventDefault();
                        toggleFormat('italic');
                        break;
                    case 'u':
                        e.preventDefault();
                        toggleFormat('underline');
                        break;
                    case 'z':
                        if (e.shiftKey) {
                            e.preventDefault();
                            document.execCommand('redo');
                        } else {
                            e.preventDefault();
                            document.execCommand('undo');
                        }
                        updateToolbarState();
                        break;
                    case 'y':
                        e.preventDefault();
                        document.execCommand('redo');
                        updateToolbarState();
                        break;
                }
            }
        });

        // Update toolbar state on input
        editor.addEventListener('input', function () {
            updateToolbarState();
        });

        // Update toolbar state on selection change
        document.addEventListener('selectionchange', function () {
            if (document.activeElement === editor) {
                updateToolbarState();
            }
        });

        // Focus editor on load
        editor.addEventListener('focus', function () {
            // Clear placeholder text on first focus
            if (editor.innerText === 'Start typing your document here...') {
                editor.innerHTML = '';
            }
        });

        // Auto-resize title input to fit content
        function resizeTitleInput() {
            const input = document.getElementById('document-title');
            if (!input) return;

            // Create a temporary span to measure text width
            const tempSpan = document.createElement('span');
            tempSpan.style.position = 'absolute';
            tempSpan.style.visibility = 'hidden';
            tempSpan.style.height = 'auto';
            tempSpan.style.width = 'auto';
            tempSpan.style.whiteSpace = 'nowrap';
            tempSpan.style.fontSize = '24px';
            tempSpan.style.fontWeight = '400';
            tempSpan.style.fontFamily = getComputedStyle(input).fontFamily;
            tempSpan.textContent = input.value || input.placeholder || 'Untitled Document';

            document.body.appendChild(tempSpan);
            const textWidth = tempSpan.offsetWidth;
            document.body.removeChild(tempSpan);

            // Set input width to text width plus padding (20px) plus a bit of buffer (10px)
            input.style.width = (textWidth + 30) + 'px';
        }

        // Update input width on change
        titleInput.addEventListener('input', resizeTitleInput);
        titleInput.addEventListener('change', resizeTitleInput);

        // Select all text when clicking on the title input
        titleInput.addEventListener('click', function() {
            this.select();
        });

        // Also select all on focus (for keyboard navigation)
        titleInput.addEventListener('focus', function() {
            this.select();
        });

        // Tooltip management functions
        function showAutocorrectTooltip(text, x, y) {
            let tooltip = document.getElementById('autocorrect-tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'autocorrect-tooltip';
                tooltip.className = 'autocorrect-tooltip';
                // Append to editor container and position relative to it
                editor.style.position = 'relative';
                editor.appendChild(tooltip);
            }

            tooltip.textContent = text;

            // Remove show class first to ensure clean state
            tooltip.classList.remove('show');

            // Position tooltip - let CSS handle opacity
            tooltip.style.position = 'absolute'; // Use absolute positioning relative to container
            tooltip.style.visibility = 'visible';
            tooltip.style.zIndex = '9999'; // Ensure it's on top
            tooltip.style.top = y + 'px';
            tooltip.style.left = '0px'; // Temporary position
            // Remove debug styling and inline opacity - let CSS handle appearance
            tooltip.style.backgroundColor = '';
            tooltip.style.border = '';
            tooltip.style.opacity = ''; // Remove inline opacity to let CSS class control it

            // Force a layout to get measurements
            const tooltipWidth = tooltip.offsetWidth;
            const tooltipHeight = tooltip.offsetHeight;

            // Position tooltip near cursor, shifted 10px right, adjusted 3px left for perfect alignment
            // Position so the arrow (8px from right edge) aligns with cursor, shifted 10px right
            let finalX = x - tooltipWidth + 8 + 10 - 3;
            let finalY = y;

            // Ensure tooltip doesn't go off the right edge of editor
            const editorWidth = editor.offsetWidth;
            if (finalX + tooltipWidth > editorWidth - 10) {
                finalX = editorWidth - tooltipWidth - 10;
            }

            // Ensure tooltip doesn't go off the left edge of editor
            if (finalX < 10) {
                finalX = 10;
            }

            // Ensure tooltip doesn't go off the top - position below cursor instead
            if (finalY < 0) {
                finalY = y + 30; // Position below cursor instead
            }

            tooltip.style.left = finalX + 'px';
            tooltip.style.top = finalY + 'px';

            // Show the tooltip immediately
            tooltip.classList.add('show');
        }

        function hideAutocorrectTooltip() {
            const tooltip = document.getElementById('autocorrect-tooltip');
            if (tooltip) {
                tooltip.classList.remove('show');
                tooltip.style.opacity = '0';
                tooltip.style.visibility = 'hidden';
            }
        }

        // Get current word being typed
        function getCurrentWord() {
            if (!editorAutocorrectEngine) return '';

            const selection = window.getSelection();
            if (selection.rangeCount === 0) return '';

              try {
                  const range = selection.getRangeAt(0);
                  
                  // Get FULL editor text using innerText (preserves newlines)
                  const fullEditorText = getEditorText();
                  
                  // Get text before cursor by cloning content and using innerText
                  const preCaretRange = range.cloneRange();
                  preCaretRange.selectNodeContents(editor);
                  preCaretRange.setEnd(range.endContainer, range.endOffset);
                  
                  // Create temporary element with cloned content to get innerText
                  const tempDiv = document.createElement('div');
                  tempDiv.appendChild(preCaretRange.cloneContents());
                  let textBeforeCursor = tempDiv.innerText || '';
                  
                  // Remove tooltip text if present
                  const tooltip = tempDiv.querySelector('.autocorrect-tooltip');
                  if (tooltip && tooltip.innerText) {
                      textBeforeCursor = textBeforeCursor.split(tooltip.innerText).join('');
                  }
                  
                  // Strip trailing newlines to match getEditorText
                  textBeforeCursor = textBeforeCursor.replace(/\n+$/, '');
                  
                  const cursorPos = textBeforeCursor.length;
                  const preceding3Chars = textBeforeCursor.substring(Math.max(0, cursorPos - 3), cursorPos);

                console.log('üîç FULL DIAGNOSTIC:');
                console.log('  üìÑ Full editor text:', JSON.stringify(fullEditorText));
                console.log('  üìè Full editor length:', fullEditorText.length);
                console.log('  üìç Cursor position:', cursorPos);
                console.log('  ‚óÄÔ∏è  3 preceding chars:', JSON.stringify(preceding3Chars));
                console.log('  ‚úÇÔ∏è  Text before cursor:', JSON.stringify(textBeforeCursor));
                console.log('  ‚úÇÔ∏è  Text before cursor length:', textBeforeCursor.length);

                // Extract word at end - stops at ANY whitespace including \n
                const wordMatch = textBeforeCursor.match(/[\w']+$/);
                const currentWord = wordMatch ? wordMatch[0] : '';

                console.log('  üìù Current word:', currentWord);

                return currentWord;

            } catch (error) {
                console.error('Error in getCurrentWord:', error);
                return '';
            }
        }

        // Replace current word with autocorrect suggestion
        function replaceCurrentWord(wordToDelete, suggestion) {
            try {
                const selection = window.getSelection();
                if (selection.rangeCount === 0) return;

                const range = selection.getRangeAt(0);

                // Create a new range to select exactly the word we want to replace
                const wordRange = document.createRange();

                // Move the range start backwards by the word length
                let startContainer = range.startContainer;
                let startOffset = range.startOffset;

                // Move backwards character by character to find the word start
                let remainingChars = wordToDelete.length;

                while (remainingChars > 0 && startContainer) {
                    if (startContainer.nodeType === Node.TEXT_NODE) {
                        const availableChars = startOffset;
                        const charsToTake = Math.min(remainingChars, availableChars);

                        startOffset -= charsToTake;
                        remainingChars -= charsToTake;

                        if (remainingChars > 0) {
                            // Need to go to previous text node
                            const walker = document.createTreeWalker(
                                editor,
                                NodeFilter.SHOW_TEXT,
                                null,
                                false
                            );
                            walker.currentNode = startContainer;
                            const prevNode = walker.previousNode();
                            if (prevNode) {
                                startContainer = prevNode;
                                startOffset = prevNode.textContent.length;
                            } else {
                                break;
                            }
                        }
                    } else {
                        break;
                    }
                }

                // Set the range to select exactly the word
                wordRange.setStart(startContainer, startOffset);
                wordRange.setEnd(range.startContainer, range.startOffset);

                // Verify we're selecting the right text
                const selectedText = wordRange.toString();
                if (selectedText === wordToDelete) {
                    // Select and replace the word
                    selection.removeAllRanges();
                    selection.addRange(wordRange);
                    document.execCommand('insertText', false, suggestion);

                    // Don't add extra space - trigger key will handle spacing
                } else {
                    // Fallback to original method
                    for (let i = 0; i < wordToDelete.length; i++) {
                        document.execCommand('delete', false, null);
                    }
                    document.execCommand('insertText', false, suggestion);

                    // No extra space needed - trigger key will handle proper spacing
                }

            } catch (error) {
                console.error('‚ùå Error replacing word:', error);
                // Fallback to simple deletion method
                try {
                    for (let i = 0; i < wordToDelete.length; i++) {
                        document.execCommand('delete', false, null);
                    }
                    document.execCommand('insertText', false, suggestion);
                } catch (fallbackError) {
                    console.error('‚ùå Fallback replacement also failed:', fallbackError);
                }
            }
        }

        // Get cursor position for tooltip placement
        function getCursorPosition() {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return null;

            try {
                const range = selection.getRangeAt(0);
                const rect = range.getBoundingClientRect();

                // Get editor bounds to calculate relative position
                const editorRect = editor.getBoundingClientRect();

                // Calculate position relative to the editor container
                return {
                    x: rect.left - editorRect.left, // Relative to editor
                    y: rect.top - editorRect.top - 35 // Relative to editor, positioned above text
                };
            } catch (error) {
                return null;
            }
        }

        // Check if current word started at a word boundary (after whitespace)
        function isAtWordBoundary() {
            try {
                const selection = window.getSelection();
                if (selection.rangeCount === 0) return true;

                const range = selection.getRangeAt(0);
                let fullText = editor.innerText || '';
                fullText = fullText.replace(/\n+$/, '');

                // Calculate cursor position using the SAME logic as getCurrentWord
                let cursorPos = 0;
                if (range.startContainer === editor) {
                    const childNodes = Array.from(editor.childNodes);
                    for (let i = 0; i < Math.min(range.startOffset, childNodes.length); i++) {
                        const node = childNodes[i];
                        if (node.nodeType === Node.TEXT_NODE) {
                            cursorPos += node.textContent.length;
                        } else if (node.nodeType === Node.ELEMENT_NODE) {
                            cursorPos += node.innerText ? node.innerText.length : 0;
                        }
                    }
                } else {
                    const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null, false);
                    let currentOffset = 0;
                    while (walker.nextNode()) {
                        const node = walker.currentNode;
                        if (node === range.startContainer) {
                            cursorPos = currentOffset + range.startOffset;
                            break;
                        }
                        currentOffset += node.textContent.length;
                    }
                }

                // Apply same cursor position fixes as getCurrentWord
                if (cursorPos > fullText.length) {
                    cursorPos = fullText.length;
                }

                if (range.startContainer.nodeType === Node.TEXT_NODE &&
                    range.startOffset === range.startContainer.textContent.length) {
                    const nodeText = range.startContainer.textContent;
                    const expectedPos = fullText.lastIndexOf(nodeText);
                    if (expectedPos !== -1 && expectedPos + nodeText.length !== cursorPos) {
                        cursorPos = expectedPos + nodeText.length;
                    }
                }

                // Check if cursor is right after whitespace
                if (cursorPos === 0) return true; // At start of document

                const prevChar = fullText[cursorPos - 1];
                return /\s/.test(prevChar); // True if cursor is right after whitespace
            } catch (error) {
                return true; // Default to allow if error
            }
        }

        // Helper to get text - use innerText which preserves newlines from contentEditable
        function getEditorText() {
            // innerText respects the visual layout and newlines
            let text = editor.innerText || '';
              
            // Remove tooltip text if present
            const tooltip = editor.querySelector('.autocorrect-tooltip');
            if (tooltip && tooltip.innerText) {
                text = text.split(tooltip.innerText).join('');
            }
              
            // Strip only trailing newlines (contentEditable adds these at end)
            text = text.replace(/\n+$/, '');
              
            return text;
        }
          
        // Track autocorrect state - simplified approach
        let autocorrectEnabled = true;
        let justAppliedAutocorrect = false;
        let lastTextLength = 0;
        let lastCursorPosition = 0;

        // Check for autocorrect suggestions using EXACT logic from typing test
        function checkForAutocorrect() {
            if (!editorAutocorrectEngine) {
                return;
            }

            const currentWord = getCurrentWord();

            // Check if we should re-enable autocorrect (if we're at word boundary or empty)
            if (!autocorrectEnabled) {
                if (isAtWordBoundary() || currentWord.length === 0) {
                    autocorrectEnabled = true;
                    console.log('‚úÖ Autocorrect re-enabled - at word boundary or empty word');
                } else {
                    console.log('‚ùå Autocorrect suppressed - not at word boundary', {
                        currentWord,
                        autocorrectEnabled,
                        isAtWordBoundary: isAtWordBoundary(),
                        textLength: (editor.innerText || '').length,
                        editorInnerText: editor.innerText,
                        editorTextContent: editor.textContent
                    });
                    currentAutocorrectSuggestion = null;
                    hideAutocorrectTooltip();
                    return;
                }
            }
              
            console.log('üîç Checking autocorrect for word:', {
                currentWord,
                wordLength: currentWord.length,
                autocorrectEnabled,
                editorText: editor.innerText.substring(0, 100)
            });

            if (currentWord.length < 3) {
                currentAutocorrectSuggestion = null;
                hideAutocorrectTooltip();
                return;
            }

            // Check if possessive form is valid (base word exists in dictionary)
            if (currentWord.endsWith("'s")) {
                const baseWord = currentWord.slice(0, -2); // Remove 's
                if (editorAutocorrectEngine.dictionarySet && editorAutocorrectEngine.dictionarySet.has(baseWord.toLowerCase())) {
                    currentAutocorrectSuggestion = null;
                    hideAutocorrectTooltip();
                    return;
                }
            }

            // Check if word is capitalized (for preserving capitalization in suggestions)
            const isCapitalized = currentWord[0] === currentWord[0].toUpperCase() && currentWord.length > 1;

            // Create lowercase version for dictionary lookup
            const wordForLookup = isCapitalized ? currentWord.toLowerCase() : currentWord;

            // Check for override corrections first
            const lowerWord = currentWord.toLowerCase();
            if (editorAutocorrectEngine.correctionOverrides && editorAutocorrectEngine.correctionOverrides[lowerWord]) {
                const suggestion = editorAutocorrectEngine.correctionOverrides[lowerWord];
                currentAutocorrectSuggestion = suggestion;

                const cursorPos = getCursorPosition();
                if (cursorPos) {
                    showAutocorrectTooltip(suggestion, cursorPos.x, cursorPos.y);
                }
                return;
            }


            // Test word splitting approach first (using lowercase for lookup)
            if (editorAutocorrectEngine.findTwoWordSplit) {
                const twoWordSplit = editorAutocorrectEngine.findTwoWordSplit(wordForLookup);

                if (twoWordSplit && twoWordSplit !== wordForLookup) {
                    // Capitalize suggestion if original word was capitalized
                    let finalSuggestion = twoWordSplit;
                    if (isCapitalized && twoWordSplit.length > 0) {
                        finalSuggestion = twoWordSplit.charAt(0).toUpperCase() + twoWordSplit.slice(1);
                    }

                    currentAutocorrectSuggestion = finalSuggestion;
                    const cursorPos = getCursorPosition();
                    if (cursorPos) {
                        showAutocorrectTooltip(finalSuggestion, cursorPos.x, cursorPos.y);
                        return;
                    }
                }
            }

            // For regular words, use findClosestWord (using lowercase for lookup)
            const suggestion = editorAutocorrectEngine.findClosestWord(wordForLookup);

            // Show tooltip if suggestion is different from original input
            if (suggestion && suggestion !== wordForLookup && suggestion !== currentWord.toLowerCase()) {
                // Capitalize suggestion if original word was capitalized
                let finalSuggestion = suggestion;
                if (isCapitalized && suggestion.length > 0) {
                    finalSuggestion = suggestion.charAt(0).toUpperCase() + suggestion.slice(1);
                }

                currentAutocorrectSuggestion = finalSuggestion;
                const cursorPos = getCursorPosition();
                if (cursorPos) {
                    showAutocorrectTooltip(finalSuggestion, cursorPos.x, cursorPos.y);
                }
            } else {
                currentAutocorrectSuggestion = null;
                hideAutocorrectTooltip();
            }
        }

        // Debounced autocorrect check
        let autocorrectTimeout;
        function debouncedAutocorrectCheck() {
            clearTimeout(autocorrectTimeout);
            autocorrectTimeout = setTimeout(checkForAutocorrect, 50);
        }

        // Track last typed key to detect space/punctuation
        let lastTypedKey = '';
          
        // Add keydown listener to track what key was pressed
        editor.addEventListener('keydown', function(e) {
            lastTypedKey = e.key;
        });
          
        // Helper to get cursor offset in text
        function getCursorOffset() {
            const selection = window.getSelection();
            if (!selection.rangeCount) return 0;
                
            const range = selection.getRangeAt(0);
                
            // Get the full text using getEditorText
            const fullText = getEditorText();
              
            // Create a temporary clone of editor up to cursor position
            const tempEditor = editor.cloneNode(true);
              
            // Find the equivalent position in the clone
            let foundNode = null;
            let foundOffset = 0;
              
            function findNodeInClone(original, clone) {
                if (original === range.startContainer) {
                    foundNode = clone;
                    foundOffset = range.startOffset;
                    return true;
                }
                  
                if (original.childNodes && clone.childNodes) {
                    for (let i = 0; i < original.childNodes.length; i++) {
                        if (findNodeInClone(original.childNodes[i], clone.childNodes[i])) {
                            return true;
                        }
                    }
                }
                return false;
            }
              
            findNodeInClone(editor, tempEditor);
              
            if (foundNode) {
                // Remove everything after the cursor in the clone
                const cloneRange = document.createRange();
                cloneRange.selectNodeContents(tempEditor);
                cloneRange.setStart(foundNode, foundOffset);
                cloneRange.deleteContents();
            }
              
            // Now get innerText from the clone (text before cursor)
            let textBeforeCursor = tempEditor.innerText || '';
              
            // Remove tooltip text if present
            const tooltip = tempEditor.querySelector('.autocorrect-tooltip');
            if (tooltip && tooltip.innerText) {
                textBeforeCursor = textBeforeCursor.replace(tooltip.innerText, '');
            }
              
            // Normalize trailing newlines to match getNormalizedEditorText
            textBeforeCursor = textBeforeCursor.replace(/\n+$/, '');
              
            console.log('üìç getCursorOffset:', {
                offset: textBeforeCursor.length,
                textBeforeCursor: textBeforeCursor.substring(Math.max(0, textBeforeCursor.length - 20)),
                fullText: fullText.substring(0, 50)
            });
              
            return textBeforeCursor.length;
        }
          
        // Add click listener to reset autocorrect state when user clicks to new position
        editor.addEventListener('mousedown', function(e) {
            // Skip if we just applied autocorrect (to avoid interfering with reset)
            if (justAppliedAutocorrect) {
                console.log('üö´ Skipping click handler - autocorrect was just applied');
                return;
            }
                
            // User clicked somewhere - enable autocorrect for new typing session
            setTimeout(() => {
                autocorrectEnabled = true;
                console.log('üñ±Ô∏è Click detected - reset autocorrect enabled');
            }, 0);
        });
          
        // Helper to get consistent text length (matching what getCurrentWord uses)
        function getConsistentTextLength() {
            return getEditorText().length;
        }
          
        // Add input listener for autocorrect tooltips (suggestion-only)
        editor.addEventListener('input', function (e) {
            const currentTextLength = getConsistentTextLength();
            const currentCursorPosition = getCursorOffset();

            // Skip processing if we just applied autocorrect
            if (justAppliedAutocorrect) {
                justAppliedAutocorrect = false;
                lastTextLength = currentTextLength;
                lastCursorPosition = currentCursorPosition;
                autocorrectEnabled = true;
                console.log('‚úÖ Autocorrect applied - reset tracking');
                updateToolbarState();
                debouncedAutocorrectCheck();
                return;
            }

            // Calculate change in text length
            const textLengthChange = currentTextLength - lastTextLength;
              
            // Simplified logic: disable autocorrect only when backspacing into completed text
            if (textLengthChange < 0) {
                // Check if we backspaced into text that existed before (cursor moved backward)
                if (currentCursorPosition < lastCursorPosition - Math.abs(textLengthChange)) {
                    autocorrectEnabled = false;
                    console.log('üî¥ Autocorrect disabled - backspaced into completed text');
                } else {
                    autocorrectEnabled = true;
                    console.log('üü¢ Autocorrect enabled - backspacing within current word');
                }
            } else {
                // Always enable autocorrect when typing forward
                autocorrectEnabled = true;
            }

            lastTextLength = currentTextLength;
            lastCursorPosition = currentCursorPosition;
            updateToolbarState();
            debouncedAutocorrectCheck();
        });

        // Handle mouse clicks to check word boundary state
        editor.addEventListener('mousedown', function (e) {
            // Reset autocorrect state when clicking - will be re-enabled if at word boundary
            setTimeout(() => {
                autocorrectEnabled = isAtWordBoundary();
            }, 0);
        });

        // Handle autocorrect application triggers and navigation keys
        editor.addEventListener('keydown', function (e) {
            // Re-enable autocorrect when typing whitespace (even if previously disabled)
            if (e.key === ' ' || e.key === 'Enter') {
                autocorrectEnabled = true;
                justAppliedAutocorrect = false; // Clear the flag when typing whitespace
            }

            // Check for autocorrect application triggers
            if (currentAutocorrectSuggestion) {
                const isEnter = e.key === 'Enter';
                const isSpace = e.key === ' ';
                const isPunctuation = [',', '.', ';', '/', '"', "'", '?', '!'].includes(e.key);

                if (isEnter || isSpace || isPunctuation) {
                    const wordToDelete = getCurrentWord();



                    // Prevent the trigger key from being processed normally
                    e.preventDefault();

                    // Replace the current word with autocorrect suggestion
                    if (wordToDelete) {
                        replaceCurrentWord(wordToDelete, currentAutocorrectSuggestion);
                        justAppliedAutocorrect = true;
                    }

                    // Hide tooltip and clear suggestion
                    hideAutocorrectTooltip();
                    currentAutocorrectSuggestion = null;

                    // Insert the trigger key that was prevented
                    if (e.key === 'Enter') {
                        // Insert line break using insertLineBreak for better contentEditable support
                        document.execCommand('insertLineBreak', false, null);
                    } else {
                        // For space and punctuation, insert the actual character
                        document.execCommand('insertText', false, e.key);
                    }
                }
            }

            // Hide tooltip on navigation keys
            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Home', 'End'].includes(e.key)) {
                hideAutocorrectTooltip();
                currentAutocorrectSuggestion = null;
            }
        });

        // Hide tooltip when clicking elsewhere
        document.addEventListener('click', function (e) {
            if (e.target !== editor) {
                hideAutocorrectTooltip();
            }
        });

          // Initialize
          updateToolbarState();
          resizeTitleInput(); // Size the title input correctly on load
          resizeFontSizeSelector(); // Size the font size selector correctly on load
          resizeFontSelector(); // Size the font selector correctly on load

          // Set default font size to 11pt
          editor.style.fontSize = '11pt';

          // Focus the editor on page load so cursor is ready
          editor.focus();
      } // Close initializeEditor function
      </script>
</body>

</html>
